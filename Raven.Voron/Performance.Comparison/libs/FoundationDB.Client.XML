<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FoundationDB.Client</name>
    </assembly>
    <members>
        <member name="T:FoundationDB.Async.AsyncTransform`2">
            <summary>Pump that takes items from a source, transform them, and outputs them</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="R"></typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncTarget`1">
            <summary>Defines a target that receive items and can throttle the producer</summary>
            <typeparam name="T">Type of values being accepted by the target</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncTarget`1.OnNextAsync(`0,System.Threading.CancellationToken)">
            <summary>Push a new item onto the target, if it can accept one</summary>
            <param name="value">New value that is being published</param>
            <param name="ct">Cancellation token that is used to abort the call if the target is blocked</param>
            <returns>Task that completes once the target has accepted the new value (or fails if the cancellation token fires)</returns>
        </member>
        <member name="M:FoundationDB.Async.IAsyncTarget`1.OnCompleted">
            <summary>Notifies the target that the producer is done and that no more values will be published</summary>
        </member>
        <member name="M:FoundationDB.Async.IAsyncTarget`1.OnError(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>Notifies the target that tere was an exception, and that no more values will be published</summary>
            <param name="error">The error that occured</param>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransform`2.Target">
            <summary>Target of the transform</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransform`2.Scheduler">
            <summary>Optional scheduler used to run the tasks</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_lock">
            <summary>Lock used to secure the global state</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_capacity">
            <summary>Maximum capacity of the queue (number of values not yet consumed)</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_done">
            <summary>If true, the last item has been sent by the source</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_receivedLast">
            <summary>If true, the last item has been received by the target</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_producerLock">
            <summary>Mutex signaling that the producer is blocked on a full queue</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_consumerLock">
            <summary>Mutex signaling that the consumer is blocked on an empty queue</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.MarkProducerAsBlocked_NeedsLocking(System.Threading.CancellationToken)">
            <summary>Delcare the producer as beeing blocked on a full queue</summary>
            <param name="ct"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.WakeUpBlockedProducer_NeedsLocking">
            <summary>Wake up the producer if it is blocked</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.MarkConsumerAsBlocked_NeedsLocking(System.Threading.CancellationToken)">
            <summary>Declare the consumer as beeing blocked on an empty queue</summary>
            <param name="ct"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.WakeUpBlockedConsumer_NeedsLocking">
            <summary>Wake up the consumer if it is blocked</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncBuffer`2">
            <summary>Buffer that holds a fixed number of items and can rate-limit the producer</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncSource`1">
            <summary>Defines a source that can produce items</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncSource`1.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>Consume a new value from the source</summary>
            <returns>Task that will return a new value, nothing (if it has completed) or on exception</returns>
        </member>
        <member name="F:FoundationDB.Async.AsyncBuffer`2.m_transform">
            <summary>Transformation applied on the values</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncBuffer`2.m_queue">
            <summary>Queue that holds items produced but not yet consumed</summary>
            <remarks>The queue can sometime go over the limit because the Complete/Error message are added without locking</remarks>
        </member>
        <member name="T:FoundationDB.Async.AsyncTaskBuffer`1">
            <summary>Buffer that holds a fixed number of Tasks, output them in arrival or completion order, and can rate-limit the producer</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:FoundationDB.Async.AsyncTaskBuffer`1.m_mode">
            <summary>How should we output results ? In arrival order or in completion order ? </summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncTaskBuffer`1.m_queue">
            <summary>Queue that holds items produced but not yet consumed</summary>
            <remarks>The queue can sometime go over the limit because the Complete/Error message are added without locking</remarks>
        </member>
        <member name="F:FoundationDB.Async.AsyncTaskBuffer`1.m_completionLock">
            <summary>Only used in mode CompletionOrder</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncTaskBuffer`1.ObserveTaskCompletion(System.Threading.Tasks.Task{`0})">
            <summary>Observe the completion of a task to wake up the consumer</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncOrderingMode">
            <summary>Order in which items in a buffer are being output</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncOrderingMode.ArrivalOrder">
            <summary>Outputs the results, respecting the arrival order.</summary>
            <remarks>If B arrives after, but completes before A, then output order will be "A, B"</remarks>
        </member>
        <member name="F:FoundationDB.Async.AsyncOrderingMode.CompletionOrder">
            <summary>Outputs the results in completion order.</summary>
            <remarks>If B arrives after, but completes before A, then output order will be "B, A"</remarks>
        </member>
        <member name="T:FoundationDB.Async.IAsyncPump`1">
            <summary>Defines a pump that can move items between a source and a target</summary>
        </member>
        <member name="M:FoundationDB.Async.IAsyncPump`1.PumpAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>Consume all the items of the source by passing them to the Target</summary>
            <param name="stopOnFirstError">If true, aborts on the first error. If false, continue processing items until the source has finished.</param>
            <param name="cancellationToken">Cancellation token that can be used to abort the pump at any time. Any unprocessed items will be lost.</param>
            <returns>Task that will complete successfully if all the items from the source have been processed by the target, or fails if an error occured or the pump was cancelled.</returns>
        </member>
        <member name="P:FoundationDB.Async.IAsyncPump`1.Source">
            <summary>Source of the pump (that produces new items)</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncPump`1.Target">
            <summary>Target of the tump (that will consume the items)</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncPump`1.IsCompleted">
            <summary>True if all the items of the source have been consumed by the target</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncPump`1">
            <summary>Pumps item from a source, and into a target</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncPump`1.PumpAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>Run the pump until the inner iterator is done, an error occurs, or the cancellation token is fired</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncPump`1.IsCompleted">
            <summary>Returns true if the pump has completed (with success or failure)</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.ComparisonHelper">
            <summary>Helper classe used to compare object of "compatible" types</summary>
        </member>
        <member name="F:FoundationDB.Client.Converters.ComparisonHelper.EqualityComparers">
            <summary>Cache of all the comparison lambda for a pair of types</summary>
            <remarks>Contains lambda that can compare two objects (of different types) for "similarity"</remarks>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.TryAdaptToString(System.Object,System.Type)">
            <summary>Tries to convert an object into an equivalent string representation (for equality comparison)</summary>
            <param name="value">Object to adapt</param>
            <returns>String equivalent of the object</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.TryAdaptToDecimal(System.Object,System.Type)">
            <summary>Tries to convert an object into an equivalent double representation (for equality comparison)</summary>
            <param name="value">Object to adapt</param>
            <returns>Double equivalent of the object</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.TryAdaptToInteger(System.Object,System.Type)">
            <summary>Tries to convert an object into an equivalent Int64 representation (for equality comparison)</summary>
            <param name="value">Object to adapt</param>
            <returns>Int64 equivalent of the object</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.AreSimilar(System.Object,System.Object)">
            <summary>Tries to compare any two object for "equality", where string "123" is considered equal to integer 123</summary>
            <param name="x">Left object to compare</param>
            <param name="y">Right object to compare</param>
            <returns>True if both objects are "similar" (ie: the represent the same logical value)</returns>
            <example>
            AreSimilar("123", 123) => true
            AreSimilar('A', "A") => true
            AreSimilar(false, 0) => true
            AreSimilar(true, 1) => true
            </example>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.AreEquivalentTypes(System.Type,System.Type)">
            <summary>Returns true if both types are considered "the same"</summary>
            <returns>Returns true if t1 is equal to t2</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.IsStringType(System.Type)">
            <summary>Return true if the type is considered to be a "string" (string, char)</summary>
            <returns>True for <see cref="T:System.String">string</see> and <see cref="T:System.Char">char</see>.</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.IsNumericType(System.Type)">
            <summary>Returns true if the specified type is considered to be a "number"</summary>
            <returns>True for integers (8, 16, 32 or 64 bits, signed or unsigned) and their Nullable versions. Bytes and Chars are not considered to be numbers because they a custom serialized</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.IsDecimalType(System.Type)">
            <summary>Returns true if the specified type is considered to be a "decimal"</summary>
            <returns>True for <see cref="T:System.Double">double</see> and <see cref="T:System.Single">float</see>.</returns>
        </member>
        <member name="T:FoundationDB.Client.Converters.ComparisonHelper.TypePair">
            <summary>Pair of types that can be used as a key in a dictionary</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.ComparisonHelper.TypePairComparer">
            <summary>Helper class to use TypePair as keys in a dictionnary</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.SimilarValueComparer">
            <summary>Object comparer that returns true if both values are "similar"</summary>
            <remarks>This comparer SHOULD NOT be used in a Dictioanry, because it violates on of the conditions: Two objects could be considered equal, but have different hashcode!</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.RawValue">
            <summary>The raw value of the file</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.Id">
            <summary>Cluster Identifier</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.Description">
            <summary>Logical description of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.Coordinators">
            <summary>List of coordination servers</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabaseExtensions">
            <summary>Provides a set of extensions methods shared by all FoundationDB database implementations.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.BeginReadOnlyTransaction(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Start a new read-only transaction on this database</summary>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <returns>New transaction instance that can read from the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginReadOnlyTransaction(CancellationToken.None))
            {
            	var result = await tr.Get(Slice.FromString("Hello"));
            	var items = await tr.GetRange(FdbKeyRange.StartsWith(Slice.FromString("ABC"))).ToListAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.BeginTransaction(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Start a new transaction on this database</summary>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <returns>New transaction instance that can read from or write to the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginTransaction(CancellationToken.None))
            {
            	tr.Set(Slice.FromString("Hello"), Slice.FromString("World"));
            	tr.Clear(Slice.FromString("OldValue"));
            	await tr.CommitAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetLocationCacheSize(FoundationDB.Client.IFdbDatabase,System.Int32)">
            <summary>Set the size of the client location cache. Raising this value can boost performance in very large databases where clients access data in a near-random pattern. Defaults to 100000.</summary>
            <param name="size">Max location cache entries</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetMaxWatches(FoundationDB.Client.IFdbDatabase,System.Int32)">
            <summary>Set the maximum number of watches allowed to be outstanding on a database connection. Increasing this number could result in increased resource usage. Reducing this number will not cancel any outstanding watches. Defaults to 10000 and cannot be larger than 1000000.</summary>
            <param name="count">Max outstanding watches</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetMachineId(FoundationDB.Client.IFdbDatabase,System.String)">
            <summary>Specify the machine ID that was passed to fdbserver processes running on the same machine as this client, for better location-aware load balancing.</summary>
            <param name="hexId">Hexadecimal ID</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetDataCenterId(FoundationDB.Client.IFdbDatabase,System.String)">
            <summary>Specify the datacenter ID that was passed to fdbserver processes running in the same datacenter as this client, for better location-aware load balancing.</summary>
            <param name="hexId">Hexadecimal ID</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Partition``1(FoundationDB.Client.IFdbDatabase,``0)">
            <summary>Return a new partition of the current database</summary>
            <typeparam name="T">Type of the value used for the partition</typeparam>
            <param name="value">Prefix of the new partition</param>
            <returns>Subspace that is the concatenation of the database global namespace and the specified <paramref name="value"/></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Partition``2(FoundationDB.Client.IFdbDatabase,``0,``1)">
            <summary>Return a new partition of the current database</summary>
            <returns>Subspace that is the concatenation of the database global namespace and the specified values</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Partition``3(FoundationDB.Client.IFdbDatabase,``0,``1,``2)">
            <summary>Return a new partition of the current database</summary>
            <returns>Subspace that is the concatenation of the database global namespace and the specified values</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Partition(FoundationDB.Client.IFdbDatabase,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Return a new partition of the current database</summary>
            <returns>Subspace that is the concatenation of the database global namespace and the specified <paramref name="tuple"/></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Pack``1(FoundationDB.Client.IFdbDatabase,``0)">
            <summary>Create a new key by appending a value to the global namespace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Pack``2(FoundationDB.Client.IFdbDatabase,``0,``1)">
            <summary>Create a new key by appending two values to the global namespace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Unpack(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Unpack a key using the current namespace of the database</summary>
            <param name="key">Key that should fit inside the current namespace of the database</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.UnpackLast``1(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Unpack a key using the current namespace of the database</summary>
            <param name="key">Key that should fit inside the current namespace of the database</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.UnpackSingle``1(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Unpack a key using the current namespace of the database</summary>
            <param name="key">Key that should fit inside the current namespace of the database</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Concat(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Add the global namespace prefix to a relative key</summary>
            <param name="keyRelative">Key that is relative to the global namespace</param>
            <returns>Key that starts with the global namespace prefix</returns>
            <example>
            // db with namespace prefix equal to"&lt;02&gt;Foo&lt;00&gt;"
            db.Concat('&lt;02&gt;Bar&lt;00&gt;') => '&lt;02&gt;Foo&lt;00&gt;&gt;&lt;02&gt;Bar&lt;00&gt;'
            db.Concat(Slice.Empty) => '&lt;02&gt;Foo&lt;00&gt;'
            db.Concat(Slice.Nil) => Slice.Nil
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Extract(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Remove the global namespace prefix of this database form the key, and return the rest of the bytes, or Slice.Nil is the key is outside the namespace</summary>
            <param name="keyAbsolute">Binary key that starts with the namespace prefix, followed by some bytes</param>
            <returns>Binary key that contain only the bytes after the namespace prefix</returns>
            <example>
            // db with namespace prefix equal to"&lt;02&gt;Foo&lt;00&gt;"
            db.Extract('&lt;02&gt;Foo&lt;00&gt;&lt;02&gt;Bar&lt;00&gt;') => '&gt;&lt;02&gt;Bar&lt;00&gt;'
            db.Extract('&lt;02&gt;Foo&lt;00&gt;') => Slice.Empty
            db.Extract('&lt;02&gt;TopSecret&lt;00&gt;&lt;02&gt;Password&lt;00&gt;') => Slice.Nil
            db.Extract(Slice.Nil) => Slice.Nil
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.GetAndWatch(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Reads the value associated with <paramref name="key"/>, and returns a Watch that will complete after a subsequent change to key in the database.</summary>
            <param name="db">Database instance.</param>
            <param name="key">Key to be looked up in the database</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property contains the current value of the key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetAndWatch(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <param name="db">Database instance.</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.GetCoordinatorsAsync(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Returns an object describing the list of the coordinators for the cluster</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.GetConfigParameter(FoundationDB.Client.IFdbDatabase,System.String,System.Threading.CancellationToken)">
            <summary>Return the value of a configuration parameter (located under '\xFF/conf/')</summary>
            <param name="db"></param>
            <param name="name">"storage_engine"</param>
            <param name="cancellationToken"></param>
            <returns>Value of '\xFF/conf/storage_engine'</returns>
        </member>
        <member name="T:FoundationDB.Client.IFdbKey">
            <summary>Allows a layer or custom class to be used as keys in a FoundationDB database</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbKey.ToFoundationDbKey">
            <summary>Returns a binary representation of this instance, to be used as a complete key in the database</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionMode.ReadOnly">
            <summary>The transaction will only allow read operations</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionMode.InsideRetryLoop">
            <summary>If set, the transaction is running within the context of a retry loop</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetAsync(FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Reads a value from the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetAsync``1(FoundationDB.Client.IFdbReadOnlyTransactional,``0,System.Threading.CancellationToken)">
            <summary>
            Reads a value from the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetKeyAsync(FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Client.FdbKeySelector,System.Threading.CancellationToken)">
            <summary>
            Resolves a key selector against the keys in the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetKeysAsync(FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Client.FdbKeySelector[],System.Threading.CancellationToken)">
            <summary>
            Resolves several key selectors against the keys in the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetKeysAsync(FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{FoundationDB.Client.FdbKeySelector},System.Threading.CancellationToken)">
            <summary>
            Resolves several key selectors against the keys in the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetValuesAsync(FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Client.Slice[],System.Threading.CancellationToken)">
            <summary>
            Reads several values from the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetValuesAsync(FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice},System.Threading.CancellationToken)">
            <summary>
            Reads several values from the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.GetValuesAsync``1(FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Reads several values from the database.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.SetAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Change the given key to have the given value in the database. If the given key was not previously present in the database it is inserted.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.SetAsync``1(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.IFdbKey,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Change the given key to have the given value in the database. If the given key was not previously present in the database it is inserted.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.ClearAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.ClearAsync``1(FoundationDB.Client.IFdbTransactional,``0,System.Threading.CancellationToken)">
            <summary>
            Remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.ClearRangeAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.FdbKeyRange,System.Threading.CancellationToken)">
            <summary>
            Remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.ClearRangeAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.ClearRangeAsync``1(FoundationDB.Client.IFdbTransactional,``0,``0,System.Threading.CancellationToken)">
            <summary>
            Remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.AtomicAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType,System.Threading.CancellationToken)">
            <summary>
            Perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionals.AtomicAsync``1(FoundationDB.Client.IFdbTransactional,``0,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType,System.Threading.CancellationToken)">
            <summary>
            Perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.
            </summary>
        </member>
        <member name="M:FoundationDB.Filters.FdbFilterExtensions.AsReadOnly(FoundationDB.Client.IFdbTransaction)">
            <summary>Return a read-only view of this transaction, that will only allow read operations.</summary>
            <param name="trans">Transaction to secure</param>
            <returns>The same transaction instance if it is already read-only, or a thin read-only wrapper around the transaction if it is writeable.</returns>
        </member>
        <member name="T:FoundationDB.Filters.FdbTransactionFilter">
            <summary>Base class for simple transaction filters</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbTransaction">
            <summary>Transaction that allows read and write operations</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbReadOnlyTransaction">
            <summary>Transaction that allows read operations</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.EnsureCanRead">
            <summary>
            Ensure thats the transaction is in a valid state for issuing read operations.
            </summary>
            <exception cref="T:System.ObjectDisposedException">If <see cref="M:System.IDisposable.Dispose">Dispose()</see> has already been called on the transaction</exception>
            <exception cref="T:System.InvalidOperationException">If the transaction as already been committed, or if the database connection has been closed</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token has been cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetAsync(FoundationDB.Client.Slice)">
            <summary>
            Reads a value from the database snapshot represented by by the current transaction.
            </summary>
            <param name="key">Key to be looked up in the database</param>
            <returns>Task that will return the value of the key if it is found, Slice.Nil if the key does not exist, or an exception</returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="key"/> is null</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token is already triggered</exception>
            <exception cref="T:System.ObjectDisposedException">If the transaction has already been completed</exception>
            <exception cref="T:System.InvalidOperationException">If the operation method is called from the Network Thread</exception>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetValuesAsync(FoundationDB.Client.Slice[])">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
            <param name="keys">Keys to be looked up in the database</param>
            <returns>Task that will return an array of values, or an exception. Each item in the array will contain the value of the key at the same index in <paramref name="keys"/>, or Slice.Nil if that key does not exist.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetKeyAsync(FoundationDB.Client.FdbKeySelector)">
            <summary>
            Resolves a key selector against the keys in the database snapshot represented by the current transaction.
            </summary>
            <param name="selector">Key selector to resolve</param>
            <returns>Task that will return the key matching the selector, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetKeysAsync(FoundationDB.Client.FdbKeySelector[])">
            <summary>
            Resolves several key selectors against the keys in the database snapshot represented by the current transaction.
            </summary>
            <param name="selectors">Key selectors to resolve</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetRangeAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetRange(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions)">
            <summary>
            Create a new range query that will read all key-value pairs in the database snapshot represented by the transaction
            </summary>
            <param name="range">Pair of key selectors defining the beginning and the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <returns>Range query that, once executed, will return all the key-value pairs matching the providing selector pair</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetAddressesForKeyAsync(FoundationDB.Client.Slice)">
            <summary>
            Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <param name="key"/> and its associated value
            </summary>
            <param name="key">Name of the key whose location is to be queried.</param>
            <returns>Task that will return an array of strings, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetReadVersionAsync">
            <summary>
            Returns this transaction snapshot read version.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.Cancel">
            <summary>Cancels the transaction. All pending or future uses of the transaction will return a TransactionCancelled error code. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetOption(FoundationDB.Client.FdbTransactionOption)">
            <summary>Set an option on this transaction that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.String)">
            <summary>Set an option on this transaction that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.Int64)">
            <summary>Set an option on this transaction that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Id">
            <summary>
            Local id of the transaction
            </summary>
            <remarks>Should only be used for diagnosticts and logging</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Context">
            <summary>
            Context of this transaction.
            </summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.IsSnapshot">
            <summary>
            If true, the transaction is operating in Snapshot mode
            </summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Snapshot">
            <summary>Return a Snapshotted version of this transaction, or the transaction itself it is already operating in Snapshot mode.</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Token">
            <summary>Cancellation Token linked to the life time of the transaction</summary>
            <remarks>Will be triggered if the transaction is aborted or disposed</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Timeout">
            <summary>Timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.RetryLimit">
            <summary>Maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.EnsureCanWrite">
            <summary>
            Ensure thats the transaction is in a valid state for issuing write operations.
            </summary>
            <exception cref="T:System.ObjectDisposedException">If <see cref="M:System.IDisposable.Dispose">Dispose()</see> has already been called on the transaction</exception>
            <exception cref="T:System.InvalidOperationException">If the transaction as already been committed, or if the database connection has been closed</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token has been cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Set(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to change the given key to have the given value. If the given key was not previously present in the database it is inserted.
            The modification affects the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Atomic(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType)">
            <summary>
            Modify the database snapshot represented by this transaction to perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.
            </summary>
            <param name="key">Name of the key whose value is to be mutated.</param>
            <param name="param">Parameter with which the atomic operation will mutate the value associated with key_name.</param>
            <param name="mutation">Type of mutation that should be performed on the key</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Clear(FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by this transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
            <param name="key">Name of the key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.ClearRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by this transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="beginKeyInclusive">Name of the key specifying the beginning of the range to clear.</param>
            <param name="endKeyExclusive">Name of the key specifying the end of the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.AddConflictRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbConflictRangeType)">
            <summary>
            Adds a conflict range to a transaction without performing the associated read or write.
            </summary>
            <param name="beginKeyInclusive">Key specifying the beginning of the conflict range. The key is included</param>
            <param name="endKeyExclusive">Key specifying the end of the conflict range. The key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Reset">
            <summary>
            Reset transaction to its initial state.
            </summary>
            <remarks>This is similar to disposing the transaction and recreating a new one.  The only state that persists through a transaction reset is that which is related to the backoff logic used by OnErrorAsync()</remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.CommitAsync">
            <summary>
            Attempts to commit the sets and clears previously applied to the database snapshot represented by this transaction to the actual database. 
            The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. 
            If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.
            </summary>
            <returns>Task that succeeds if the transaction was comitted successfully, or fails if the transaction failed to commit.</returns>
            <remarks>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, CommitAsync() will throw CommitUnknownResult error. The OnErrorAsync() function treats this error as retryable, so retry loops that don’t check for CommitUnknownResult could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.GetCommittedVersion">
            <summary>
            Retrieves the database version number at which a given transaction was committed.
            </summary>
            <returns></returns>
            <remarks>
            CommitAsync() must have been called on this transaction and the resulting task must have completed successfully before this function is callged, or the behavior is undefined.
            Read-only transactions do not modify the database when committed and will have a committed version of -1.
            Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.SetReadVersion(System.Int64)">
            <summary>
            Sets the snapshot read version used by a transaction. This is not needed in simple cases.
            </summary>
            <param name="version">Read version to use in this transaction</param>
            <remarks>
            If the given version is too old, subsequent reads will fail with error_code_past_version; if it is too new, subsequent reads may be delayed indefinitely and/or fail with error_code_future_version.
            If any of Get*() methods have been called on this transaction already, the result is undefined.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.OnErrorAsync(FoundationDB.Client.FdbError)">
            <summary>
            Implements the recommended retry and backoff behavior for a transaction.
            
            This function knows which of the error codes generated by other query functions represent temporary error conditions and which represent application errors that should be handled by the application. 
            It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.
            </summary>
            <param name="code">FdbError code thrown by the previous command</param>
            <returns>Returns a task that completes if the operation can be safely retried, or that rethrows the original exception if the operation is not retryable.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Watch(FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Watch a key for any change in the database.
            </summary>
            <param name="key">Key to watch</param>
            <param name="cancellationToken">CancellationToken used to abort the watch if the caller doesn't want to wait anymore. Note that you can manually cancel the watch by calling Cancel() on the returned FdbWatch instance</param>
            <returns>FdbWatch that can be awaited and will complete when the key has changed in the database, or cancellation occurs. You can call Cancel() at any time if you are not interested in watching the key anymore. You MUST always call Dispose() if the watch completes or is cancelled, to ensure that resources are released properly.</returns>
            <remarks>You can directly await an FdbWatch, or obtain a Task&lt;Slice&gt; by reading the <see cref="P:FoundationDB.Client.FdbWatch.Task"/> property.</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbTransaction.IsReadOnly">
            <summary>Returns true if this transaction instance only allow read operations</summary>
            <remarks>Attempting to call a write method on a read-only transaction will immediately throw an exception</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbTransaction.Size">
            <summary>
            Estimated payload size of the transaction (in bytes)
            </summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_transaction">
            <summary>Inner database</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_owner">
            <summary>If true, dispose the inner database when we get disposed</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_disposed">
            <summary>If true, we have been disposed</summary>
        </member>
        <member name="M:FoundationDB.Filters.FdbTransactionFilter.#ctor(FoundationDB.Client.IFdbTransaction,System.Boolean,System.Boolean)">
            <summary>Base constructor for transaction filters</summary>
            <param name="trans">Underlying transaction that will be exposed as read-only</param>
            <param name="forceReadOnly">If true, force the transaction to be read-only. If false, use the read-only mode of the underlying transaction</param>
            <param name="ownsTransaction">If true, the underlying transaction will also be disposed when this instance is disposed</param>
        </member>
        <member name="F:FoundationDB.Filters.FdbReadOnlyTransactionFilter.m_transaction">
            <summary>Inner database</summary>
        </member>
        <member name="T:FoundationDB.Filters.FdbDatabaseFilter">
            <summary>Base class for simple database filters</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbDatabase">
            <summary>FoundationDB database instance that supports read operations.</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbReadOnlyTransactional">
            <summary>Transactional context that can execute read-only transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransactional.ReadAsync(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Runs a transactional lambda function inside a read-only transaction context, with optional retry-logic.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransactional.ReadAsync``1(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Runs a transactional lambda function inside a read-only transaction context, with optional retry-logic.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbTransactional">
            <summary>Transactional context that can execute read and/or write transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.WriteAsync(System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block inside a write-only transaction context, with optional retry logic.</summary>
            <param name="handler">Idempotent handler that will be retried until the transaction commits, or a non-recoverable error occurs.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block inside a read-write transaction context, with optional retry logic.</summary>
            <param name="asyncHandler">Idempotent asynchronous handler that will be retried until the transaction commits, or a non-recoverable error occurs.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync``1(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block that returns a value, inside a read-write transaction context, with optional retry logic.</summary>
            <param name="asyncHandler">Idempotent asynchronous lambda function that will be retried until the transaction commits, or a non-recoverable error occurs. The returned value of the last call will be the result of the operation.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Result of the lambda function if the transaction committed sucessfully.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.WriteAsync(System.Action{FoundationDB.Client.IFdbTransaction},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync``1(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbDatabase.BeginTransaction(FoundationDB.Client.FdbTransactionMode,System.Threading.CancellationToken,FoundationDB.Client.FdbOperationContext)">
            <summary>Start a new transaction on this database, with the specified mode</summary>
            <param name="mode">Mode of the transaction (read-only, read-write, ....)</param>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <param name="context">Existing parent context, if the transaction needs to be linked with a retry loop, or a parent transaction. If null, will create a new standalone context valid only for this transaction</param>
            <returns>New transaction instance that can read from or write to the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginTransaction(CancellationToken.None))
            {
            	tr.Set(Slice.FromString("Hello"), Slice.FromString("World"));
            	tr.Clear(Slice.FromString("OldValue"));
            	await tr.CommitAsync();
            }</example>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.Name">
            <summary>Name of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.Token">
            <summary>Returns a cancellation token that is linked with the lifetime of this database instance</summary>
            <remarks>The token will be cancelled if the database instance is disposed</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.GlobalSpace">
            <summary>Returns the global namespace used by this database instance</summary>
            <remarks>Makes a copy of the subspace tuple, so you should not call this property a lot. Use any of the Partition(..) methods to create a subspace of the database</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.DefaultTimeout">
            <summary>Default Timeout value (in milliseconds) for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.DefaultRetryLimit">
            <summary>Default Retry Limit value for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_database">
            <summary>Inner database</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_owner">
            <summary>If true, dispose the inner database when we get disposed</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_disposed">
            <summary>If true, we have been disposed</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Database">
            <summary>Database instance configured to read and write data from this partition</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Token">
            <summary>Returns a cancellation token that is linked with the lifetime of this database instance</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.GlobalSpace">
            <summary>Returns the global namespace used by this database instance</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbLoggedDatabase">
            <summary>Database filter that logs all the transactions</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbLoggedDatabase.OnCommitted">
            <summary>Handler called everytime a transaction is successfully committed</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbLoggingExtensions.Annotate(FoundationDB.Client.IFdbReadOnlyTransaction,System.String)">
            <summary>Anotate a logged transaction</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbTransactionLog.Command">
            <summary>Base class of all types of operations performed on a transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Id">
            <summary>Id of the logged transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Operations">
            <summary>Number of operations performed by the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Commands">
            <summary>List of all commands processed by the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StartTimestamp">
            <summary>Timestamp of the start of transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StopTimestamp">
            <summary>Timestamp of the end of transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StartedUtc">
            <summary>Timestamp (UTC) of the start of transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StoppedUtc">
            <summary>Tmiestamp (UTC) of the end of the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.CommittedUtc">
            <summary>Timestamp (UTC) of the last successfull commit of the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.CommittedVersion">
            <summary>Committed version of the transaction (if a commit was successfull)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Step">
            <summary>Internal step counter of the transaction</summary>
            <remarks>This counter is used to detect sequential vs parallel commands</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.CommitSize">
            <summary>Commit size of the last commit attempt</summary>
            <remarks>This value only account for commands in the last attempt</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.TotalCommitSize">
            <summary>Total of the commit size of all attempts performed by this transaction</summary>
            <remarks>This value include the size of all previous retry attempts</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Completed">
            <summary>If true, the transaction has completed (either Commit() completed successfully or Dispose was called)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Attempts">
            <summary>Total number of attempts to commit this transaction</summary>
            <remarks>This value is increment on each call to Commit()</remarks>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbTransactionLog.Command">
            <summary>Base class of all types of operations performed on a transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.Command.GetArguments">
            <summary>Returns a formatted representation of the arguments, for logging purpose</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.Command.GetResult">
            <summary>Returns a formatted representation of the results, for logging purpose</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Op">
            <summary>Return the type of operation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Snapshot">
            <summary>If true, the operation was executed in Snapshot mode</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Step">
            <summary>Return the step number of this command</summary>
            <remarks>All commands with the same step number where started in parallel</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.StartOffset">
            <summary>Number of ticks, since the start of the transaction, when the operation was started</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.EndOffset">
            <summary>Number of ticks, since the start of the transaction, when the operation completed (or null if it did not complete)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Error">
            <summary>Exception thrown by this operation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ArgumentBytes">
            <summary>Total size (in bytes) of the arguments</summary>
            <remarks>For selectors, only include the size of the keys</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ResultBytes">
            <summary>Total size (in bytes) of the result, or null if this operation does not produce a result</summary>
            <remarks>Includes the keys and values for range reads</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ThreadId">
            <summary>Id of the thread that started the command</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Duration">
            <summary>Total duration of the command, or TimeSpan.Zero if the command is not yet completed</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Mode">
            <summary>Return the mode of the operation (Read, Write, Metadata, Watch, ...)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ShortName">
            <summary>Returns the short version of the command name (up to two characters)</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbTransactionLog.Command`1">
            <summary>Base class of all types of operations performed on a transaction, that return a result</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command`1.Result">
            <summary>Optional result of the operation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetCommand.Key">
            <summary>Key modified in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetCommand.Value">
            <summary>Value written to the key</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ClearCommand.Key">
            <summary>Key cleared from the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ClearRangeCommand.Begin">
            <summary>Begin of the range cleared</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ClearRangeCommand.End">
            <summary>End of the range cleared</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AtomicCommand.Mutation">
            <summary>Type of mutation performed on the key</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AtomicCommand.Key">
            <summary>Key modified in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AtomicCommand.Param">
            <summary>Parameter depending of the type of mutation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AddConflictRangeCommand.Type">
            <summary>Type of conflict</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AddConflictRangeCommand.Begin">
            <summary>Begin of the conflict range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AddConflictRangeCommand.End">
            <summary>End of the conflict range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetCommand.Key">
            <summary>Key read from the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetKeyCommand.Selector">
            <summary>Selector to a key in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetValuesCommand.Keys">
            <summary>List of keys read from the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetKeysCommand.Selectors">
            <summary>List of selectors looked up in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.Begin">
            <summary>Selector to the start of the range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.End">
            <summary>Selector to the end of the range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.Options">
            <summary>Options of the range read</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.Iteration">
            <summary>Iteration number</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbLoggedTransaction">
            <summary>Transaction filter that logs and measure all operations performed on the underlying transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbLoggedTransaction.Log">
            <summary>Log of all operations performed on this transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbLoggedTransaction.Committed">
            <summary>Handler that will be called when this transaction commits successfully</summary>
        </member>
        <member name="T:FoundationDB.Filters.PrefixRewriterTransaction">
            <summary>[PROOF OF CONCEPT, DO NOT USE YET!] Transaction filter that automatically appends/remove a fixed prefix to all keys</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFuture">
            <summary>Helper class to create FDBFutures</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.FromHandle``1(FoundationDB.Client.Native.FutureHandle,System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Create a new FdbFuture&lt;<typeparamref name="T"/>&gt; from an FDBFuture* pointer</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="handle">FDBFuture* pointer</param>
            <param name="selector">Func that will be called to get the result once the future completes (and did not fail)</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Object that tracks the execution of the FDBFuture handle</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.FromHandleArray``1(FoundationDB.Client.Native.FutureHandle[],System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Create a new FdbFutureArray&lt;<typeparamref name="T"/>&gt; from an array of FDBFuture* pointers</summary>
            <typeparam name="T">Type of the items of the arrayreturn by the task</typeparam>
            <param name="handles">Array of FDBFuture* pointers</param>
            <param name="selector">Func that will be called for each future that complete (and did not fail)</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Object that tracks the execution of all the FDBFuture handles</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.CreateTaskFromHandle``1(FoundationDB.Client.Native.FutureHandle,System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Wrap a FdbFuture&lt;<typeparamref name="T"/>&gt; handle into a Task&lt;<typeparamref name="T"/>&gt;</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="handle">FDBFuture* pointer</param>
            <param name="continuation">Lambda that will be called once the future completes sucessfully, to extract the result from the future handle.</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Task that will either return the result of the continuation lambda, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.CreateTaskFromHandleArray``1(FoundationDB.Client.Native.FutureHandle[],System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Wrap multiple FdbFuture&lt;<typeparamref name="T"/>&gt; handles into a single Task&lt;<typeparamref name="T"/>[]&gt;</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="handles">Array of FDBFuture* pointers</param>
            <param name="continuation">Lambda that will be called once for each future that completes sucessfully, to extract the result from the future handle.</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Task that will either return all the results of the continuation lambdas, or an exception</returns>
            <remarks>If at least one future fails, the whole task will fail.</remarks>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.COMPLETED">
            <summary>The future has completed (either success or failure)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.HAS_POSTED_ASYNC_COMPLETION">
            <summary>A completion/failure/cancellation has been posted on the thread pool</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.CANCELLED">
            <summary>The future has been cancelled from an external source (manually, or via then CancellationTokeb)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.MEMORY_RELEASED">
            <summary>The resources allocated by this future have been released</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.READY">
            <summary>The future has been constructed, and is listening for the callbacks</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.DISPOSED">
            <summary>Dispose has been called</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFuture`1">
            <summary>Base class for all FDBFuture wrappers</summary>
            <typeparam name="T">Type of the Task's result</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.m_flags">
            <summary>Flags of the future (bit field of FLAG_xxx values)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.m_key">
            <summary>Future key in the callback dictionary</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.m_ctr">
            <summary>Optionnal registration on the parent Cancellation Token</summary>
            <remarks>Is only valid if FLAG_HAS_CTR is set</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.CloseHandles">
            <summary>Close all the handles managed by this future</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.CancelHandles">
            <summary>Cancel all the handles managed by this future</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.ReleaseMemory">
            <summary>Release all memory allocated by this future</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetResult(`0,System.Boolean)">
            <summary>Set the result of this future</summary>
            <param name="result">Result of the future</param>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetFaulted(System.Exception,System.Boolean)">
            <summary>Fault the future's Task</summary>
            <param name="e">Error that will be the result of the task</param>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetFaulted(System.Collections.Generic.IEnumerable{System.Exception},System.Boolean)">
            <summary>Fault the future's Task</summary>
            <param name="e">Error that will be the result of the task</param>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetCanceled(System.Boolean)">
            <summary>Cancel the future's Task</summary>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostCompletionOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0},`0)">
            <summary>Defer setting the result of a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostFailureOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0},System.Exception)">
            <summary>Defer failing a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostFailureOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0},System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>Defer failing a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostCancellationOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0})">
            <summary>Defer cancelling a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.s_futures">
            <summary>List of all pending futures that have not yet completed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.s_futureCounter">
            <summary>Internal counter to generated a unique parameter value for each futures</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.RegisterCallback(FoundationDB.Client.FdbFuture{`0})">
            <summary>Register a future in the callback context and return the corresponding callback parameter</summary>
            <param name="future">Future instance</param>
            <returns>Parameter that can be passed to FutureSetCallback and that uniquely identify this future.</returns>
            <remarks>The caller MUST call ClearCallbackHandler to ensure that the future instance is removed from the list</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.UnregisterCallback(FoundationDB.Client.FdbFuture{`0})">
            <summary>Remove a future from the callback handler dictionary</summary>
            <param name="future">Future that has just completed, or is being destroyed</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.GetAwaiter">
            <summary>Make the Future awaitable</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.Cancel">
            <summary>Try to abort the task (if it is still running)</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.Clear">
            <summary>Free memory allocated by this future after it has completed.</summary>
            <remarks>This method provides no benefit to most application code, and should only be called when attempting to write thread-safe custom layers.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbFuture`1.IsReady">
            <summary>Return true if the future has completed (successfully or not)</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFutureArray`1">
            <summary>FDBFuture[] wrapper</summary>
            <typeparam name="T">Type of result</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.m_handles">
            <summary>Value of the 'FDBFuture*'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.m_pending">
            <summary>Counter of callbacks that still need to fire.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.m_resultSelector">
            <summary>Lambda used to extract the result of this FDBFuture</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.CallbackHandler">
            <summary>Cached delegate of the future completion callback handler</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureArray`1.FutureCompletionCallback(System.IntPtr,System.IntPtr)">
            <summary>Handler called when a FDBFuture becomes ready</summary>
            <param name="futureHandle">Handle on the future that became ready</param>
            <param name="parameter">Paramter to the callback (unused)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureArray`1.HandleCompletion(System.Boolean)">
            <summary>Update the Task with the state of a ready Future</summary>
            <param name="future">Future that should be ready</param>
            <returns>True if we got a result, or false in case of error (or invalid state)</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbWatch">
            <summary>Factory class for keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbWatch.GetAwaiter">
            <summary>Returns an awaiter for the Watch</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbWatch.Cancel">
            <summary>Cancel the watch. It will immediately stop monitoring the key. Has no effect if the watch has already fired</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbWatch.Dispose">
            <summary>Dispose the resources allocated by the watch.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.Key">
            <summary>Key that is being watched</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.Value">
            <summary>Original value of the key, at the time the watch was created (optional)</summary>
            <remarks>This property will return Slice.Nil if the original value was not known at the creation of this Watch instance.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.IsAlive">
            <summary>Returns true if the watch is still active, or false if it fired or was cancelled</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.HasChanged">
            <summary>Returns true if the watch has fired signaling that the key may have changed in the database</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.Task">
            <summary>Task that will complete when the watch fires, or is cancelled. It will return the watched key, or an exception.</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MaxKeySize">
            <summary>Keys cannot exceed 10,000 bytes</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MaxValueSize">
            <summary>Values cannot exceed 100,000 bytes</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MaxTransactionWriteSize">
            <summary>Maximum size of total written keys and values by a transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.s_started">
            <summary>Flag indicating if FDB has been initialized or not</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.GetMaxApiVersion">
            <summary>Returns the maximum API version currently supported by this binding</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Success(FoundationDB.Client.FdbError)">
            <summary>Returns true if the error code represents a success</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Failed(FoundationDB.Client.FdbError)">
            <summary>Returns true if the error code represents a failure</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.DieOnError(FoundationDB.Client.FdbError)">
            <summary>Throws an exception if the code represents a failure</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.GetErrorMessage(FoundationDB.Client.FdbError)">
            <summary>Return the error message matching the specified error code</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.MapToException(FoundationDB.Client.FdbError)">
            <summary>Maps an error code into an Exception (to be throwned)</summary>
            <param name="code"></param>
            <returns>Exception object corresponding to the error code, or null if the code is not an error</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.StartEventLoop">
            <summary>Starts the thread running the FDB event loop</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.StopEventLoop">
            <summary>Stops the thread running the FDB event loop</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.EventLoop">
            <summary>Entry point for the Network Thread</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.EnsureNotOnNetworkThread(System.String)">
            <summary>Throws if the current thread is the Network Thread.</summary>
            <remarks>Should be used to ensure that we do not execute tasks continuations from the network thread, to avoid dead-locks.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.CreateClusterAsync(System.Threading.CancellationToken)">
            <summary>Opens a connection to an existing FoundationDB cluster using the default cluster file</summary>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbCluster, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.CreateClusterAsync(System.String,System.Threading.CancellationToken)">
            <summary>Opens a connection to an existing FDB Cluster</summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbCluster, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(System.Threading.CancellationToken)">
            <summary>
            Open the "DB" database on the cluster specified by the default cluster file
            </summary>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>
            Open the "DB" database on the cluster specified by the default cluster file, and with the specified global space
            </summary>
            <param name="globalSpace">Global subspace used as a prefix for all keys and layers</param>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Open a database on the specified cluster
            </summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="dbName">Name of the database, or "DB" if not specified.</param>
            <param name="cancellationToken">Cancellation Token</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <remarks>As of 1.0, the only supported database name is "DB"</remarks>
            <exception cref="T:System.InvalidOperationException">If <paramref name="dbName"/> is anything other than "DB"</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(System.String,System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Open a database on the specified cluster
            </summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="dbName">Name of the database. Must be 'DB'</param>
            <param name="globalSpace">Global subspace used as a prefix for all keys and layers</param>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <remarks>As of 1.0, the only supported database name is 'DB'</remarks>
            <exception cref="T:System.InvalidOperationException">If <paramref name="dbName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.EnsureIsStarted">
            <summary>Ensure that we have loaded the C API library, and that the Network Thread has been started</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Start">
            <summary>Select the correct API version, and start the Network Thread</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Stop">
            <summary>Stop the Network Thread</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.IsNetworkRunning">
            <summary>Returns true if the Network thread start is executing, otherwise falsse</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.IsNetworkThread">
            <summary>Returns 'true' if we are currently running on the Event Loop thread</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.MaxValue">
            <summary>"\xFF\xFF"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.MinValue">
            <summary>"\xFF\xFF"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.ConfigPrefix">
            <summary>"\xFF/conf/..."</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.Coordinators">
            <summary>"\xFF/coordinators"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.KeyServers">
            <summary>"\xFF/keyServer/(key_boundary)" => (..., node_id, ...)</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.ServerKeys">
            <summary>"\xFF/serverKeys/(node_id)/(key_boundary)" => ('' | '1')</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.ServerList">
            <summary>"\xFF/serverList/(node_id)" => (..., node_id, machine_id, datacenter_id, ...)</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.SystemKeys.Workers">
            <summary>"\xFF/workers/(ip:port)/..." => datacenter + machine + mclass</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.SystemKeys.GetConfigKey(System.String)">
            <summary>Return the corresponding key for a config attribute</summary>
            <param name="name">"foo"</param>
            <returns>"\xFF/config/foo"</returns>
        </member>
        <member name="T:FoundationDB.Client.Fdb.Options">
            <summary>Global settings for the FoundationDB binding</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.Options.NativeLibPath">
            <summary>Custom path from where to load the native C API library. If null, let the CLR find the dll. If String.Empty let Win32's LoadLibrary find the correct dll, else use the specified path to load the library</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.DisableNativeLibraryPreloading">
            <summary>Disable preloading of the native C API library. The CLR will handle the binding of the library.</summary>
            <remarks>This MUST be called before calling any other methods !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.EnableNativeLibraryPreloading">
            <summary>Enable automatic preloading of the native C API library. The operating system will handle the binding of the library</summary>
            <remarks>This MUST be called before calling any other methods !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetNativeLibPath(System.String)">
            <summary>Preload the native C API library from a specifc path (relative of absolute) where the fdb_c.dll library is located</summary>
            <example>SetNativeLibPath(@".\libs\x64") will attempt to load ".\libs\x64\fdb_c.dll"</example>
            <remarks>This MUST be called before calling any other methods !</remarks>
        </member>
        <member name="F:FoundationDB.Client.Fdb.Options.TracePath">
            <summary>Default path to the network thread tracing file</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTracePath(System.String)">
            <summary>Sets the custom path where the logs will be stored</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.PartitionTable.OpenRootAsync(System.Threading.CancellationToken)">
            <summary>Open the root partition of the default cluster</summary>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.PartitionTable.OpenRootAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>Open the root partition of a cluster</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.PartitionTable.OpenPartitionAsync(FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>Open a specific partition of the default cluster</summary>
            <param name="globalSpace"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.PartitionTable.OpenPartitionAsync(System.String,System.String,FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>Open a specific partition of a cluster</summary>
            <param name="clusterFile"></param>
            <param name="dbName"></param>
            <param name="globalSpace"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.PartitionTable.OpenNamedPartitionAsync(FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Open a named partition of the default cluster, using the root DirectoryLayer to discover the partition's prefix</summary>
            <param name="partitionPath"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.PartitionTable.OpenNamedPartitionAsync(System.String,System.String,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Open a named partition of a cluster, using its root DirectoryLayer to discover the partition's prefix</summary>
            <param name="clusterFile"></param>
            <param name="dbName"></param>
            <param name="partitionPath"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:FoundationDB.Client.FdbConflictRangeType">
            <summary>Defines a type of conflict artificially added to a transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbConflictRangeType.Read">
            <summary>
            Used to add a read conflict range.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbConflictRangeType.Write">
            <summary>
            Used to add a write conflict range.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbMutationType">
            <summary>Defines a type of mutation applied to a key</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Invalid">
            <summary>
            Invalid
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Add">
            <summary>
            Performs an addition of little-endian integers. If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``. The integers to be added must be stored in a little-endian representation.  They can be signed in two's complement representation or unsigned. You can add to an integer at a known offset in the value by prepending the appropriate number of zero bytes to ``param`` and padding with zero bytes to match the length of the value. However, this offset technique requires that you know the addition will not cause the integer field within the value to overflow.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.And">
            <summary>
            Performs a bitwise ``and`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Or">
            <summary>
            Performs a bitwise ``or`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Xor">
            <summary>
            Performs a bitwise ``xor`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.Bulk.FdbBulkOperations">
            <summary>Wrapper on a transaction, that will use Snmapshot mode on all read operations</summary>
        </member>
        <member name="M:FoundationDB.Client.Bulk.FdbBulkOperations.BulkInsertAsync(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{FoundationDB.Client.Slice,FoundationDB.Client.Slice}},System.IProgress{System.Int64},System.Threading.CancellationToken)">
            <summary>Insert a (large) sequence of key/value pairs into the database, by using as many transactions as necessary</summary>
            <param name="data">Sequence of key/value pairs</param>
            <param name="cancellationToken">Cancellation Token</param>
            <returns>Total number of values inserted in the database</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbTransaction">
            <summary>Wraps an FDB_TRANSACTION handle</summary>
            <summary>Wraps an FDB_TRANSACTION handle</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_snapshotted">
            <summary>Snapshot version of this transaction (lazily allocated)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_state">
            <summary>Current state of the transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_database">
            <summary>Owner database that created this instance</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_context">
            <summary>Context of the transaction when running inside a retry loop, or other custom scenario</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_id">
            <summary>Unique internal id for this transaction (for debugging purpose)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_handle">
            <summary>FDB_TRANSACTION* handle</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_readOnly">
            <summary>True if the transaction has been opened in read-only mode</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_payloadBytes">
            <summary>Estimated size of written data (in bytes)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_timeout">
            <summary>Timeout (in ms) of this transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_retryLimit">
            <summary>Retry Limit of this transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_cts">
            <summary>Cancelletation source specific to this instance.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_token">
            <summary>CancellationToken that should be used for all async operations executing inside this transaction</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetOption(FoundationDB.Client.FdbTransactionOption)">
            <summary>Set an option on this transaction that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.String)">
            <summary>Set an option on this transaction that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.Int64)">
            <summary>Set an option on this transaction that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetReadVersionAsync">
            <summary>Returns this transaction snapshot read version.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetCommittedVersion">
            <summary>Retrieves the database version number at which a given transaction was committed.</summary>
            <returns>Version number, or -1 if this transaction was not committed (or did nothing)</returns>
            <remarks>The value return by this method is undefined if Commit has not been called</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetReadVersion(System.Int64)">
            <summary>
            Sets the snapshot read version used by a transaction. This is not needed in simple cases.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetAsync(FoundationDB.Client.Slice)">
            <summary>
            Reads a value from the database snapshot represented by transaction.
            </summary>
            <param name="key">Key to be looked up in the database</param>
            <returns>Task that will return the value of the key if it is found, Slice.Nil if the key does not exist, or an exception</returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="key"/> is null</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token is already triggered</exception>
            <exception cref="T:System.ObjectDisposedException">If the transaction has already been completed</exception>
            <exception cref="T:System.InvalidOperationException">If the operation method is called from the Network Thread</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetKeyValueArrayResult(FoundationDB.Client.Native.FutureHandle,System.Boolean@)">
            <summary>Extract a chunk of result from a completed Future</summary>
            <param name="h">Handle to the completed Future</param>
            <param name="more">Receives true if there are more result, or false if all results have been transmited</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetRangeCoreAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32,System.Boolean)">
            <summary>Asynchronously fetch a new page of results</summary>
            <returns>True if Chunk contains a new page of results. False if all results have been read.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetRangeAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by limit, target_bytes, or mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, StreamingMode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetKeyAsync(FoundationDB.Client.FdbKeySelector)">
            <summary>Resolves a key selector against the keys in the database snapshot represented by transaction.</summary>
            <param name="selector">Key selector to resolve</param>
            <returns>Task that will return the key matching the selector, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetKeysAsync(FoundationDB.Client.FdbKeySelector[])">
            <summary>
            Resolves several key selectors against the keys in the database snapshot represented by the current transaction.
            </summary>
            <param name="selectors">Key selectors to resolve</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Set(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to change the given key to have the given value. If the given key was not previously present in the database it is inserted.
            The modification affects the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Atomic(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType)">
            <summary>
            Modify the database snapshot represented by this transaction to perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.
            </summary>
            <param name="key">Name of the key whose value is to be mutated.</param>
            <param name="param">Parameter with which the atomic operation will mutate the value associated with key_name.</param>
            <param name="mutation">Type of mutation that should be performed on the key</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Clear(FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
            <param name="key">Name of the key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.ClearRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="beginKeyInclusive">Name of the key specifying the beginning of the range to clear.</param>
            <param name="endKeyExclusive">Name of the key specifying the end of the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.AddConflictRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbConflictRangeType)">
            <summary>
            Adds a conflict range to a transaction without performing the associated read or write.
            </summary>
            <param name="beginKeyInclusive">Key specifying the beginning of the conflict range. The key is included</param>
            <param name="endKeyExclusive">Key specifying the end of the conflict range. The key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetAddressesForKeyAsync(FoundationDB.Client.Slice)">
            <summary>
            Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <param name="key"/> and its associated value
            </summary>
            <param name="key">Name of the key whose location is to be queried.</param>
            <returns>Task that will return an array of strings, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetValuesAsync(FoundationDB.Client.Slice[])">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.CommitAsync">
            <summary>
            Attempts to commit the sets and clears previously applied to the database snapshot represented by this transaction to the actual database. 
            The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. 
            If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.
            </summary>
            <returns>Task that succeeds if the transaction was comitted successfully, or fails if the transaction failed to commit.</returns>
            <remarks>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, CommitAsync() will throw CommitUnknownResult error. The OnErrorAsync() function treats this error as retryable, so retry loops that don’t check for CommitUnknownResult could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Watch(FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Watch a key for any change in the database.
            </summary>
            <param name="key">Key to watch</param>
            <param name="cancellationToken">CancellationToken used to abort the watch if the caller doesn't want to wait anymore. Note that you can manually cancel the watch by calling Cancel() on the returned FdbWatch instance</param>
            <returns>FdbWatch that can be awaited and will complete when the key has changed in the database, or cancellation occurs. You can call Cancel() at any time if you are not interested in watching the key anymore. You MUST always call Dispose() if the watch completes or is cancelled, to ensure that resources are released properly.</returns>
            <remarks>You can directly await an FdbWatch, or obtain a Task&lt;Slice&gt; by reading the <see cref="P:FoundationDB.Client.FdbWatch.Task"/> property</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.OnErrorAsync(FoundationDB.Client.FdbError)">
            <summary>
            Implements the recommended retry and backoff behavior for a transaction.
            
            This function knows which of the error codes generated by other query functions represent temporary error conditions and which represent application errors that should be handled by the application. 
            It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.
            </summary>
            <param name="code">FdbError code thrown by the previous command</param>
            <returns>Returns a task that completes if the operation can be safely retried, or that rethrows the original exception if the operation is not retryable.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Reset">
            <summary>Reset the transaction to its initial state.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Cancel">
            <summary>Rollback this transaction, and dispose it. It should not be used after that.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureCanRead">
            <summary>Throws if the transaction is not a valid state (for reading/writing) and that we can proceed with a read operation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureCanWrite">
            <summary>Throws if the transaction is not a valid state (for writing) and that we can proceed with a write operation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureCanRetry">
            <summary>Throws if the transaction is not safely retryable</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureStilValid(System.Boolean,System.Boolean)">
            <summary>Throws if the transaction is not a valid state (for reading/writing) and that we can proceed with a read or write operation</summary>
            <param name="allowFromNetworkThread">If true, this operation is allowed to run from a callback on the network thread and should NEVER block.</param>
            <param name="allowFailedState">If true, this operation can run even if the transaction is in a failed state.</param>
            <exception cref="T:System.ObjectDisposedException">If Dispose as already been called on the transaction</exception>
            <exception cref="T:System.InvalidOperationException">If CommitAsync() or Rollback() have already been called on the transaction, or if the database has been closed</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureNotFailedOrDisposed">
            <summary>Throws if the transaction is not a valid state (for reading/writing)</summary>
            <exception cref="T:System.ObjectDisposedException">If Dispose as already been called on the transaction</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Dispose">
            <summary>
            Destroy the transaction and release all allocated resources, including all non-committed changes.
            </summary>
            <remarks>This instance will not be usable again and most methods will throws an ObjectDisposedException.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Snapshot">
            <summary>Returns a version of this transaction that perform snapshotted operations</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Id">
            <summary>Internal local identifier of the transaction</summary>
            <remarks>Should only used for logging/debugging purpose.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.IsSnapshot">
            <summary>Always returns false. Use the <see cref="P:FoundationDB.Client.FdbTransaction.Snapshot"/> property to get a different view of this transaction that will perform snapshot reads.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Context">
            <summary>Returns the context of this transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Database">
            <summary>Database instance that manages this transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Handle">
            <summary>Native FDB_TRANSACTION* handle</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.StillAlive">
            <summary>If true, the transaction is still pending (not committed or rolledback).</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Size">
            <summary>Estimated size of the transaction payload (in bytes)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Token">
            <summary>Cancellation Token that is cancelled when the transaction is disposed</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.IsReadOnly">
            <summary>Returns true if this transaction only supports read operations, or false if it supports both read and write operations</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Timeout">
            <summary>Timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.RetryLimit">
            <summary>Maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.State">
            <summary>Get/Sets the internal state of the exception</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbTransaction.Snapshotted">
            <summary>Wrapper on a transaction, that will use Snmapshot mode on all read operations</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.HasMore">
            <summary>Set to true if there are more results in the database than could fit in a single chunk</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.Chunk">
            <summary>Contains the items that where </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.Iteration">
            <summary>Iteration number of this chunk (used when paging through a long range)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.Reversed">
            <summary>Set to true if the original range read was reversed (meaning the items are in reverse lexicographic order</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.Count">
            <summary>Returns the number of results in this chunk</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.IsEmpty">
            <summary>Returns true if the chunk does not contain any item.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.First">
            <summary>Returns the first item in the chunk</summary>
            <remarks>Note that if the range is reversed, then the first item will be GREATER than the last !</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.Last">
            <summary>Returns the last item in the chunk</summary>
            <remarks>Note that if the range is reversed, then the last item will be LESS than the first!</remarks>
        </member>
        <member name="T:FoundationDB.Client.FdbTransactionExtensions">
            <summary>Provides a set of extensions methods shared by all FoundationDB transaction implementations.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithAccessToSystemKeys``1(``0)">
            <summary>Allows this transaction to read and modify system keys (those that start with the byte 0xFF)</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithPrioritySystemImmediate``1(``0)">
            <summary>Specifies that this transaction should be treated as highest priority and that lower priority transactions should block behind this one. Use is discouraged outside of low-level tools</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithPriorityBatch``1(``0)">
            <summary>Specifies that this transaction should be treated as low priority and that default priority transactions should be processed first. Useful for doing batch work simultaneously with latency-sensitive work</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithNextWriteNoWriteConflictRange``1(``0)">
            <summary>The next write performed on this transaction will not generate a write conflict range. As a result, other transactions which read the key(s) being modified by the next write will not conflict with this transaction. Care needs to be taken when using this option on a transaction that is shared between multiple threads. When setting this option, write conflict ranges will be disabled on the next write operation, regardless of what thread it is on.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithTimeout``1(``0,System.TimeSpan)">
            <summary>Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
            <param name="timeout">Timeout (with millisecond precision), or TimeSpan.Zero for infinite timeout</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithTimeout``1(``0,System.Int32)">
            <summary>Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
            <param name="milliseconds">Timeout in millisecond, or 0 for infinite timeout</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithRetryLimit``1(``0,System.Int32)">
            <summary>Set a maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetRange(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeySelectorPair,FoundationDB.Client.FdbRangeOptions)">
            <summary>
            Create a new range query that will read all key-value pairs in the database snapshot represented by the transaction
            </summary>
            <param name="range">Pair of key selectors defining the beginning and the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <returns>Range query that, once executed, will return all the key-value pairs matching the providing selector pair</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetRangeAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeySelectorPair,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="range">key selector pair defining the beginning and the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.Clear``1(FoundationDB.Client.IFdbTransaction,``0)">
            <summary>
            Modify the database snapshot represented by this transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
            <param name="key">Key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.ClearRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange)">
            <summary>
            Modify the database snapshot represented by this transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="range">Pair of keys defining the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange,FoundationDB.Client.FdbConflictRangeType)">
            <summary>
            Adds a conflict range to a transaction without performing the associated read or write.
            </summary>
            <param name="range">Range of the keys specifying the conflict range. The end key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange)">
            <summary>
            Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictRange``1(FoundationDB.Client.IFdbTransaction,``0,``0)">
            <summary>
            Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictKey(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice)">
            <summary>
            Adds a key to the transaction’s read conflict ranges as if you had read the key. As a result, other transactions that write to this key could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictKey``1(FoundationDB.Client.IFdbTransaction,``0)">
            <summary>
            Adds a key to the transaction’s read conflict ranges as if you had read the key. As a result, other transactions that write to this key could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange)">
            <summary>
            Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictRange``1(FoundationDB.Client.IFdbTransaction,``0,``0)">
            <summary>
            Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictKey(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice)">
            <summary>
            Adds a key to the transaction’s write conflict ranges as if you had cleared the key. As a result, other transactions that concurrently read this key could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictKey``1(FoundationDB.Client.IFdbTransaction,``0)">
            <summary>
            Adds a key to the transaction’s write conflict ranges as if you had cleared the key. As a result, other transactions that concurrently read this key could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetAndWatchAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Reads the value associated with <paramref name="key"/>, and returns a Watch that will complete after a subsequent change to key in the database.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Key to be looked up in the database</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property contains the current value of the key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.SetAndWatch(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.SetAndWatch``1(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,``0,FoundationDB.Client.IFdbValueEncoder{``0},System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetValuesAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <returns>Task that will return an array of values, or an exception. Each item in the array will contain the value of the key at the same index in <paramref name="keys"/>, or Slice.Nil if that key does not exist.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetValuesAsync``1(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice},FoundationDB.Client.IFdbValueEncoder{``0})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <returns>Task that will return an array of values, or an exception. Each item in the array will contain the value of the key at the same index in <paramref name="keys"/>, or Slice.Nil if that key does not exist.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetKeysAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.FdbKeySelector})">
            <summary>
            Resolves several key selectors against the keys in the database snapshot represented by the current transaction.
            </summary>
            <param name="selectors">Sequence of key selectors to resolve</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeOptions">
            <summary>Container class for options in a Range query</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.#ctor">
            <summary>Create a new empty set of options</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.#ctor(System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{FoundationDB.Client.FdbStreamingMode})">
            <summary>Create a new set of options</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.#ctor(FoundationDB.Client.FdbRangeOptions)">
            <summary>Copy an existing set of options</summary>
            <param name="options"></param>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.EnsureDefaults(FoundationDB.Client.FdbRangeOptions,System.Int32,System.Int32,FoundationDB.Client.FdbStreamingMode,System.Boolean)">
            <summary>Add all missing values from the provided defaults</summary>
            <param name="options">Options provided by the caller (can be null)</param>
            <param name="limit">Default value for Limit if not provided</param>
            <param name="targetBytes">Default TargetBytes for limit if not provided</param>
            <param name="mode">Default value for StreamingMode if not provided</param>
            <param name="reverse">Default value for Reverse if not provided</param>
            <returns>Options with all the values filled</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.EnsureLegalValues">
            <summary>Throws if values are not legal</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.Limit">
            <summary>Maximum number of items to return</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.Reverse">
            <summary>If true, results are returned in reverse order (from last to rist)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.TargetBytes">
            <summary>Maximum number of bytes to read</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.Mode">
            <summary>Streaming mode</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbOperationContext">
            <summary>
            Represents the context of a retryable transactional function wich accept a read-only or read-write transaction.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunReadAsync(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbReadOnlyTransaction},System.Threading.CancellationToken)">
            <summary>Run a read-only operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunReadWithResultAsync``1(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task{``0}},System.Action{FoundationDB.Client.IFdbReadOnlyTransaction},System.Threading.CancellationToken)">
            <summary>Run a read-only operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunWriteAsync(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Run a read/write operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunWriteAsync(FoundationDB.Client.IFdbDatabase,System.Action{FoundationDB.Client.IFdbTransaction},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Run a write operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunWriteWithResultAsync``1(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Run a read/write operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Database">
            <summary>The database used by the operation</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Result">
            <summary>Result of the operation (or null)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Token">
            <summary>Cancellation token associated with the operation</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Abort">
            <summary>If set to true, will abort and not commit the transaction. If false, will try to commit the transaction (and retry on failure)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Retries">
            <summary>Current attempt number (0 for first, 1+ for retries)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.StartedUtc">
            <summary>Date at wich the operation was first started</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Duration">
            <summary>Time spent since the start of the first attempt</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Committed">
            <summary>If true, the transaction has been committed successfully</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Shared">
            <summary>If true, the lifetime of the context is handled by an external retry loop. If false, the context is linked to the lifetime of the transaction instance.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Mode">
            <summary>Mode of the transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.TokenSource">
            <summary>Internal source of cancellation, able to abort any pending IO operations attached to this transaction</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbExceptIterator`3">
            <summary>Returns only the values for the keys that are in the first sub query, but not in the others</summary>
            <typeparam name="TSource">Type of the elements from the source async sequences</typeparam>
            <typeparam name="TKey">Type of the keys extracted from the source elements</typeparam>
            <typeparam name="TResult">Type of the elements of resulting async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Client.FdbQueryMergeIterator`3">
            <summary>Performs a Merge Sort on several concurrent range queries</summary>
            <typeparam name="TKey">Type of values extracted from the keys, that will be used for sorting</typeparam>
            <typeparam name="TResult">Type of results returned</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncIterator`1">
            <summary>Base class for all async iterators</summary>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncEnumerable`1">
            <summary>Asynchronous version of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface, allowing elements of the enumerable sequence to be retrieved asynchronously.</summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncEnumerable`1.GetEnumerator">
            <summary>Gets an asynchronous enumerator over the sequence.</summary>
            <returns>Enumerator for asynchronous enumeration over the sequence.</returns>
        </member>
        <member name="M:FoundationDB.Linq.IFdbAsyncEnumerable`1.GetEnumerator(FoundationDB.Linq.FdbAsyncMode)">
            <summary>
            Gets an asynchronous enumerator over the sequence.
            </summary>
            <param name="mode">Defines how the enumerator will be used by the caller. The source provider can use the mode to optimize how the results are produced.</param>
            <returns>Enumerator for asynchronous enumeration over the sequence.</returns>
        </member>
        <member name="T:FoundationDB.Async.IAsyncEnumerator`1">
            <summary>Asynchronous version of the <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface, allowing elements to be retrieved asynchronously.</summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncEnumerator`1.MoveNext(System.Threading.CancellationToken)">
            <summary>Advances the enumerator to the next element in the sequence, returning the result asynchronously.</summary>
            <param name="cancellationToken">Cancellation token that can be used to cancel the operation.</param>
            <returns>
            Task containing the result of the operation: true if the enumerator was successfully advanced 
            to the next element; false if the enumerator has passed the end of the sequence.
            </returns>
        </member>
        <member name="P:FoundationDB.Async.IAsyncEnumerator`1.Current">
            <summary>Gets the current element in the iteration.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbQueryMergeIterator`3.OnNextAsync(System.Threading.CancellationToken)">
            <summary>Finds the next smallest item from all the active iterators</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbExceptIterator`3.Select``1(System.Func{`2,``0})">
            <summary>Apply a transformation on the results of the intersection</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbExceptIterator`3.Take(System.Int32)">
            <summary>Limit the number of elements returned by the intersection</summary>
            <param name="limit">Maximum number of results to return</param>
            <returns>New Intersect that will only return the specified number of results</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbIntersectIterator`3">
            <summary>Returns only the values for the keys that are in all the sub queries</summary>
            <typeparam name="TSource">Type of the elements from the source async sequences</typeparam>
            <typeparam name="TKey">Type of the keys extracted from the source elements</typeparam>
            <typeparam name="TResult">Type of the elements of resulting async sequence</typeparam>
        </member>
        <member name="M:FoundationDB.Client.FdbIntersectIterator`3.Select``1(System.Func{`2,``0})">
            <summary>Apply a transformation on the results of the intersection</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbIntersectIterator`3.Take(System.Int32)">
            <summary>Limit the number of elements returned by the intersection</summary>
            <param name="limit">Maximum number of results to return</param>
            <returns>New Intersect that will only return the specified number of results</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbKeySelectorPair">
            <summary>Represents of pair of key selectors that range 'GetKey(Begin) &lt;= key &lt; GetKey(End)'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelectorPair.Begin">
            <summary>Start of the range</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelectorPair.End">
            <summary>End of the range</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.#ctor(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector)">
            <summary>Create a new pair of key selectors</summary>
            <param name="beginInclusive">Selector for key from which to start iterating</param>
            <param name="endExclusive">Selector for key where to stop iterating</param>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector)">
            <summary>Factory method for a pair of key selectors</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Create a new pair of key selectors using FIRST_GREATER_OR_EQUAL on both keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create``1(``0,``0)">
            <summary>Create a new pair of key selectors using FIRST_GREATER_OR_EQUAL on both keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create(FoundationDB.Client.FdbKeyRange)">
            <summary>Create a new pair of key selectors using FIRST_GREATER_OR_EQUAL on both keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.StartsWith(FoundationDB.Client.Slice)">
            <summary>Create a new pair of key selectors that will select all the keys that start with the specified prefix</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.StartsWith``1(``0)">
            <summary>Create a new pair of key selectors that will select all the keys that start with the specified prefix</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.ToString">
            <summary>Returns a printable version of the pair of key selectors</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbMergeSortIterator`3">
            <summary>Merge all the elements of several ordered queries into one single async sequence</summary>
            <typeparam name="TSource">Type of the elements from the source async sequences</typeparam>
            <typeparam name="TKey">Type of the keys extracted from the source elements</typeparam>
            <typeparam name="TResult">Type of the elements of resulting async sequence</typeparam>
        </member>
        <member name="M:FoundationDB.Client.FdbMergeSortIterator`3.Select``1(System.Func{`2,``0})">
            <summary>Apply a transformation on the results of the merge sort</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbMergeSortIterator`3.Take(System.Int32)">
            <summary>Limit the number of elements returned by the MergeSort</summary>
            <param name="limit">Maximum number of results to return</param>
            <returns>New MergeSort that will only return the specified number of results</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQuery`1">
            <summary>Query describing an ongoing GetRange operation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.#ctor(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,System.Func{System.Collections.Generic.KeyValuePair{FoundationDB.Client.Slice,FoundationDB.Client.Slice},`0},System.Boolean,FoundationDB.Client.FdbRangeOptions)">
            <summary>Construct a query with a set of initial settings</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Take(System.Int32)">
            <summary>Only return up to a specific number of results</summary>
            <param name="count">Maximum number of results to return</param>
            <returns>A new query object that will only return up to <paramref name="count"/> results when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Reversed">
            <summary>Reverse the order in which the results will be returned</summary>
            <returns>A new query object that will return the results in reverse order when executed</returns>
            <rremarks>Calling Reversed() on an already reversed query will cancel the effect, and the results will be returned in their natural order.</rremarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.WithTargetBytes(System.Int32)">
            <summary>Use a specific target bytes size</summary>
            <param name="bytes"></param>
            <returns>A new query object that will use the specified target bytes size when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.WithMode(FoundationDB.Client.FdbStreamingMode)">
            <summary>Use a different Streaming Mode</summary>
            <param name="mode">Streaming mode to use when reading the results from the database</param>
            <returns>A new query object that will use the specified streaming mode when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.UseTransaction(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Force the query to use a specific transaction</summary>
            <param name="transaction">Transaction to use when executing this query</param>
            <returns>A new query object that will use the specified transaction when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ToListAsync">
            <summary>Return a list of all the elements of the range results</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ToArrayAsync">
            <summary>Return an array with all the elements of the range results</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Select``1(System.Func{`0,``0})">
            <summary>Projects each element of the range results into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Where(System.Func{`0,System.Boolean})">
            <summary>Filters the range results based on a predicate.</summary>
            <remarks>Caution: filtering occurs on the client side !</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.AnyAsync">
            <summary>Return true if the range query returns at least one element, or false if there was no result.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.NoneAsync">
            <summary>Return true if the range query does not return any valid elements, or false if there was at least one result.</summary>
            <remarks>This is a convenience method that is there to help porting layer code from other languages. This is strictly equivalent to calling "!(await query.AnyAsync())".</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ForEachAsync(System.Action{`0})">
            <summary>Execute an action on each key/value pair of the range results</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ToString">
            <summary>Returns a printable version of the range query</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Begin">
            <summary>Key selector describing the beginning of the range that will be queried</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.End">
            <summary>Key selector describing the end of the range that will be queried</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Range">
            <summary>Key selector pair describing the beginning and end of the range that will be queried</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Options">
            <summary>Stores all the settings for this range query</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Limit">
            <summary>Limit in number of rows to return</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.TargetBytes">
            <summary>Limit in number of bytes to return</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Mode">
            <summary>Streaming mode</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Snapshot">
            <summary>Should we perform the range using snapshot mode ?</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Reverse">
            <summary>Should the results returned in reverse order (from last key to first key)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Transaction">
            <summary>Parent transaction used to perform the GetRange operation</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQuery`1.ResultIterator">
            <summary>Async iterator that fetches the results by batch, but return them one by one</summary>
            <typeparam name="TResult">Type of the results returned</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_resultTransform">
            <summary>Lambda used to transform pairs of key/value into the expected result</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_chunkIterator">
            <summary>Iterator used to read chunks from the database</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_outOfChunks">
            <summary>True if we have reached the last page</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_chunk">
            <summary>Current chunk (may contain all records or only a segment at a time)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_itemsRemainingInChunk">
            <summary>Number of remaining items in the current batch</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_currentOffsetInChunk">
            <summary>Offset in the current batch of the current item</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQuery`1.PagingIterator">
            <summary>Async iterator that fetches the results by batch, but return them one by one</summary>
            <typeparam name="TResult">Type of the results returned</typeparam>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.FetchNextPageAsync(System.Threading.CancellationToken)">
            <summary>Asynchronously fetch a new page of results</summary>
            <param name="cancellationToken"></param>
            <returns>True if Chunk contains a new page of results. False if all results have been read.</returns>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Begin">
            <summary>Key selector describing the beginning of the current range (when paging)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.End">
            <summary>Key selector describing the end of the current range (when paging)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Remaining">
            <summary>If non null, contains the remaining allowed number of rows</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Iteration">
            <summary>Iteration number of current page (in iterator mode)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Chunk">
            <summary>Current page (may contain all records or only a segment at a time)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.HasMore">
            <summary>If true, we have more records pending</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.AtEnd">
            <summary>True if we have reached the last page</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.RowCount">
            <summary>Running total of rows that have been read</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.PendingReadTask">
            <summary>Current/Last batch read task</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbException">
            <summary>FoundationDB API Error Code</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbException.Code">
            <summary>Gets the code for this error.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbException.Success">
            <summary>Determine if this FDBError represents a success code from the native layer.</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbKeyRange">
            <summary>Represents a pair of keys defining the range 'Begin &lt;= key &gt; End'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeyRange.Begin">
            <summary>Start of the range</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeyRange.End">
            <summary>End of the range</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.#ctor(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Create a new range of keys
            </summary>
            <param name="begin">Start of range (usually included)</param>
            <param name="end">End of range (usually excluded)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.StartsWith(FoundationDB.Client.Slice)">
            <summary>Create a range that will return all keys starting with <paramref name="prefix"/>: ('prefix' &lt;= k &lt; strinc('prefix'))</summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.PrefixedBy(FoundationDB.Client.Slice)">
            <summary>Create a range that selects all keys starting with <paramref name="prefix"/>, but not the prefix itself: ('prefix\x00' &lt;= k &lt; string('prefix')</summary>
            <param name="prefix">Key prefix (that will be excluded from the range)</param>
            <returns>Range including all keys with the specified prefix.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.FromKey(FoundationDB.Client.Slice)">
            <summary>Create a range that will only return <paramref name="key"/> itself ('key' &lt;= k &lt; 'key\x00')</summary>
            <param name="key">Key that will be returned by the range</param>
            <returns>Range that only return the specified key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Contains(FoundationDB.Client.Slice)">
            <summary>Returns true, if the key is contained in the range</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Test(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Test if <paramref name="key"/> is contained inside the range</summary>
            <param name="key">Key that will be compared with the the range's bounds</param>
            <param name="endIncluded">If true, the End bound is inclusive, otherwise it is exclusive</param>
            <returns>-1 if key is less than the lower bound of the range (<paramref name="key"/> &lt; Begin), +1 if the key is greater or equal to the higher bound of the range (<paramref name="key"/> &gt;= End) or 0 if it is inside the range (Begin &lt;= <paramref name="key"/> &lt; End)</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.ToString">
            <summary>Returns a printable version of the range</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbKeyRange.Empty">
            <summary>Returns an empty pair of keys</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbKey">
            <summary>Factory class for keys</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.MinValue">
            <summary>Smallest possible key ('\0')</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.MaxValue">
            <summary>Bigest possible key ('\xFF'), excluding the system keys</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.Directory">
            <summary>Default Directory Layer prefix ('\xFE')</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.System">
            <summary>Default System prefix ('\xFF')</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Increment(FoundationDB.Client.Slice)">
            <summary>Returns the first key lexicographically that does not have the passed in <paramref name="slice"/> as a prefix</summary>
            <param name="slice">Slice to increment</param>
            <returns>New slice that is guaranteed to be the first key lexicographically higher than <paramref name="slice"/> which does not have <paramref name="slice"/> as a prefix</returns>
            <remarks>If the last byte is already equal to 0xFF, it will rollover to 0x00 and the next byte will be incremented.</remarks>
            <exception cref="!:System.ArgumentException">If the Slice is equal to Slice.Nil</exception>
            <exception cref="!:System.OverflowException">If the Slice is the empty string or consists only of 0xFF bytes</exception>
            <example>
            FdbKey.Increment(Slice.FromString("ABC")) =&gt; "ABD"
            FdbKey.Increment(Slice.FromHexa("01 FF")) =&gt; { 02 }
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Merge(FoundationDB.Client.Slice,FoundationDB.Client.Slice[])">
            <summary>Merge an array of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Array of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Merge(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Merge a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.SplitIntoSegments(System.Byte[],System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>Split a buffer containing multiple contiguous segments into an array of segments</summary>
            <param name="buffer">Buffer containing all the segments</param>
            <param name="start">Offset of the start of the first segment</param>
            <param name="endOffsets">Array containing, for each segment, the offset of the following segment</param>
            <returns>Array of segments</returns>
            <example>SplitIntoSegments("HelloWorld", 0, [5, 10]) => [{"Hello"}, {"World"}]</example>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.BatchedRange(System.Int32,System.Int32,System.Int32)">
            <summary>Split a range of indexes into several batches</summary>
            <param name="offset">Offset from which to start counting</param>
            <param name="count">Total number of values that will be returned</param>
            <param name="batchSize">Maximum size of each batch</param>
            <returns>Collection of B batches each containing at most <paramref name="batchSize"/> contiguous indices, counting from <paramref name="offset"/> to (<paramref name="offset"/> + <paramref name="count"/> - 1)</returns>
            <example>Batched(0, 100, 20) => [ {0..19}, {20..39}, {40..59}, {60..79}, {80..99} ]</example>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Batched(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Split range of indexes into a fixed number of 'worker' sequence, that will consume batches in parallel
            </summary>
            <param name="offset">Offset from which to start counting</param>
            <param name="count">Total number of values that will be returned</param>
            <param name="workers">Number of concurrent workers that will take batches from the pool</param>
            <param name="batchSize">Maximum size of each batch</param>
            <returns>List of '<paramref name="workers"/>' enumerables that all fetch batches of values from the same common pool. All enumerables will stop when the last batch as been consumed by the last worker.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Dump(FoundationDB.Client.Slice)">
            <summary>Produce a user-friendly version of the slice</summary>
            <param name="key">Random binary key</param>
            <returns>User friendly version of the key. Attempts to decode the key as a tuple first. Then as an ASCII string. Then as an hex dump of the key.</returns>
            <remarks>This can be slow, and should only be used for logging or troubleshooting.</remarks>
        </member>
        <member name="T:FoundationDB.Client.FdbTransactionOption">
            <summary>Defines a set of options for a transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.None">
            <summary>None</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.CausalWriteRisky">
            <summary>
            The transaction, if not self-conflicting, may be committed a second time after commit succeeds, in the event of a fault
            Parameter: Option takes no parameter
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:FoundationDB.Client.FdbTransactionOption.CausalReadRisky" -->
        <member name="F:FoundationDB.Client.FdbTransactionOption.CausalReadDisable">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.NextWriteNoWriteConflictRange">
            <summary>
            The next write performed on this transaction will not generate a write conflict range. As a result, other transactions which read the key(s) being modified by the next write will not conflict with this transaction. Care needs to be taken when using this option on a transaction that is shared between multiple threads. When setting this option, write conflict ranges will be disabled on the next write operation, regardless of what thread it is on.
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.CheckWritesEnable">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.ReadYourWrites">
            <summary>
            Reads performed by a transaction will not see any prior mutations that occured in that transaction, instead seeing the value which was in the database at the transaction's read version. This option may provide a small performance benefit for the client, but also disables a number of client-side optimizations which are beneficial for transactions which tend to read and write the same keys within a single transaction. Also note that with this option invoked any outstanding reads will return errors when transaction commit is called (rather than the normal behavior of commit waiting for outstanding reads to complete).
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.ReadAheadDisable">
            <summary>
            Disables read-ahead caching for range reads. Under normal operation, a transaction will read extra rows from the database into cache if range reads are used to page through a series of data one row at a time (i.e. if a range read with a one row limit is followed by another one row range read starting immediately after the result of the first).
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DurabilityDataCenter">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DurabilityRisky">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DevNullIsWebScale">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.PrioritySystemImmediate">
            <summary>
            Specifies that this transaction should be treated as highest priority and that lower priority transactions should block behind this one. Use is discouraged outside of low-level tools
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.PriorityBatch">
            <summary>
            Specifies that this transaction should be treated as low priority and that default priority transactions should be processed first. Useful for doing batch work simultaneously with latency-sensitive work
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.InitializeNewDatabase">
            <summary>
            This is a write-only transaction which sets the initial configuration
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.AccessSystemKeys">
            <summary>
            Allows this transaction to read and modify system keys (those that start with the byte 0xFF)
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DebugDump">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.Timeout">
            <summary>
            Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.
            Parameter: (Int) value in milliseconds of timeout
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.RetryLimit">
            <summary>
            Set a maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.
            Parameter: (Int) number of times to retry
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabaseOption">
            <summary>Defines a set of options for the database connection</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.LocationCacheSize">
            <summary>
            Set the size of the client location cache. Raising this value can boost performance in very large databases where clients access data in a near-random pattern. Defaults to 100000.
            Parameter: (Int) Max location cache entries
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.MaxWatches">
            <summary>
            Set the maximum number of watches allowed to be outstanding on a database connection. Increasing this number could result in increased resource usage. Reducing this number will not cancel any outstanding watches. Defaults to 10000 and cannot be larger than 1000000.
            Parameter: (Int) Max outstanding watches
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.MachineId">
            <summary>
            Specify the machine ID that was passed to fdbserver processes running on the same machine as this client, for better location-aware load balancing.
            Parameter: (String) Hexadecimal ID
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.DataCenterId">
            <summary>
            Specify the datacenter ID that was passed to fdbserver processes running in the same datacenter as this client, for better location-aware load balancing.
            Parameter: (String) Hexadecimal ID
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbStreamingMode">
            <summary>Defines how the client would like the data in a range a returned</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.WantAll">
            <summary>
            Client intends to consume the entire range and would like it all transferred as early as possible. 
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Iterator">
            <summary>
            The default. The client doesn't know how much of the range it is likely to used and wants different performance concerns to be balanced. Only a small portion of data is transferred to the client initially (in order to minimize costs if the client doesn't read the entire range), and as the caller iterates over more items in the range larger batches will be transferred in order to minimize latency.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Exact">
            <summary>
            Infrequently used. The client has passed a specific row limit and wants that many rows delivered in a single batch. Because of iterator operation in client drivers make request batches transparent to the user, consider WANT_ALL StreamingMode instead. A row limit must be specified if this mode is used.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Small">
            <summary>
            Infrequently used. Transfer data in batches small enough to not be much more expensive than reading individual rows, to minimize cost if iteration stops early.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Medium">
            <summary>
            Infrequently used. Transfer data in batches sized in between small and large. Usually the default
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Large">
            <summary>
            Infrequently used. Transfer data in batches large enough to be, in a high-concurrency environment, nearly as efficient as possible. If the client stops iteration early, some disk and network bandwidth may be wasted. The batch size may still be too small to allow a single client to get high throughput from the database, so if that is what you need consider the SERIAL StreamingMode.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Serial">
            <summary>
            Transfer data in batches large enough that an individual client can get reasonable read bandwidth from the database. If the client stops iteration early, considerable disk and network bandwidth may be wasted.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbClusterOption">
            <summary>Defines a set of options for the cluster connection</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbClusterOption.None">
            <summary>None</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbClusterOption.Invalid">
            <summary>This option is only a placeholder for C compatibility and should not be used</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbNetworkOption">
            <summary>Defines a set of options for the network thread</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.None">
            <summary>None</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.LocalAddress">
            <summary>
            Deprecated
            Parameter: (String) IP:PORT
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.ClusterFile">
            <summary>
            Deprecated
            Parameter: (String) Path to cluster file
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TraceEnable">
            <summary>
            Enables trace output to a file in a directory of the clients choosing
            Parameter: (String) path to output directory (or NULL for current working directory)
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbError">
            <summary>FoundationDB API Error Code</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.Success">
            <summary>Success</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.OperationFailed">
            <summary>Operation failed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TimedOut">
            <summary> Operation timed out</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.PastVersion">
            <summary>Version no longer available</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureVersion">
            <summary>Request for future version</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NotCommitted">
            <summary>Transaction not committed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.CommitUnknownResult">
            <summary>Transaction may or may not have committed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TransactionCancelled">
            <summary>Operation aborted because the transaction was cancelled</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TransactionTimedOut">
            <summary>Operation aborted because the transaction timed out</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TooManyWatches">
            <summary>Too many watches are currently set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.OperationCancelled">
            <summary>Asynchronous operation cancelled</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.PlatformError">
            <summary>A platform error occurred</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.LargeAllocFailed">
            <summary>Large block allocation failed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.PerformanceCounterError">
            <summary>QueryPerformanceCounter doesn’t work</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.IOError">
            <summary>A disk i/o operation failed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FileNotFound">
            <summary>File not found</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.BindFailed">
            <summary>Unable to bind to network</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FileNotReadable">
            <summary>File could not be read from</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FileNotWriteable">
            <summary>File could not be written to</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NoClusterFileFound">
            <summary>No cluster file found in current directory or default location</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ClusterFileTooLarge">
            <summary>Cluster file to large to be read</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ClientInvalidOperation">
            <summary>The client made an invalid API call</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.CommitReadIncomplete">
            <summary>Commit with incomplete read</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TestSpecificationInvalid">
            <summary>The test specification is invalid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.KeyOutsideLegalRange">
            <summary>The specified key was outside the legal range</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvertedRange">
            <summary>The specified range has a begin key larger than the end key</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidOptionValue">
            <summary>An invalid value was passed with the specified option</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidOption">
            <summary>Option not valid in this context</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NetworkNotSetup">
            <summary>Action not possible before the network is configured</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NetworkAlreadySetup">
            <summary>Network can be configured only once</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ReadVersionAlreadySet">
            <summary>Transaction already has a read version set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.VersionInvalid">
            <summary>Version not valid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.RangeLimitsInvalid">
            <summary>getRange limits not valid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidDatabaseName">
            <summary>Database name not supported in this version</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.AttributeNotFound">
            <summary>Attribute not found in string</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureNotSet">
            <summary>The future has not been set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureNotError">
            <summary>The future is not an error</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureReleased">
            <summary>The future has been released</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.IncompatibleProtocolVersion">
            <summary>Incompatible protocol version</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TransactionTooLarge">
            <summary>Transaction too large</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.KeyTooLarge">
            <summary>Key too large</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ValueTooLarge">
            <summary>Value too large</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ConnectionStringInvalid">
            <summary>Connection string invalid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.AddressInUse">
            <summary>Local address in use</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidLocalAddress">
            <summary>Invalid local address</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionUnset">
            <summary>Api version must be set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionAlreadySet">
            <summary>Api version may be set only once</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionInvalid">
            <summary>Api version not valid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionNotSupported">
            <summary>Api version not supported in this version or binding</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ExactModeWithoutLimits">
            <summary>EXACT streaming mode requires limits, but none were given</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.UnknownError">
            <summary>An unknown error occurred</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InternalError">
            <summary>An internal error occurred</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given path.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If prefix is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given path.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If prefix is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens a subdirectory with the given path.
            If the subdirectory does not exist, it is created (creating intermediate subdirectories if necessary).
            If prefix is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If layer is specified, it is checked against the layer of an existing subdirectory or set as the layer of a new subdirectory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.String[],System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens a subdirectory with the given path.
            If the subdirectory does not exist, it is created (creating intermediate subdirectories if necessary).
            If prefix is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If layer is specified, it is checked against the layer of an existing subdirectory or set as the layer of a new subdirectory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An error is raised if the given directory already exists.
            If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An error is raised if the given directory already exists.
            If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.String[],System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An error is raised if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An error is raised if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.String,System.Threading.CancellationToken)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.String[],System.String,System.Threading.CancellationToken)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.MoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Moves the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.MoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String[],System.Threading.CancellationToken)">
            <summary>Moves the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryMoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Attempts to move the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryMoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.String[],System.Threading.CancellationToken)">
            <summary>Attempts to move the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.MoveAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Moves the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.MoveAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Moves the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryMoveAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Attempts to move the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryMoveAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Attempts to move the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryRemoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryRemoveAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryRemoveAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.Threading.CancellationToken)">
            <summary>Attempts to remove the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Checks if a directory already exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbReadOnlyTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Checks if a directory already exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Checks if this directory exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbReadOnlyTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbReadOnlyTransactional,FoundationDB.Layers.Tuples.IFdbTuple,System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>, if it exists</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbReadOnlyTransactional,System.String[],System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>, if it exists</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Returns the list of all the subdirectories of the current directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Returns the list of all the subdirectories of the current directory, it it exists.</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbValueEncoder`1">
            <summary>Defines method to pack or unpack objects</summary>
            <typeparam name="T">The type of objects to pack or unpack</typeparam>
        </member>
        <member name="M:FoundationDB.Client.IFdbValueEncoder`1.Encode(`0)">
            <summary>Serialize a <typeparamref name="T"/> instance into a packed representation</summary>
            <param name="value">Value to serialize</param>
            <returns>Packed representation of <paramref name="value"/></returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbValueEncoder`1.Decode(FoundationDB.Client.Slice)">
            <summary>Deserialize a packed representation into a <typeparamref name="T"/> instance</summary>
            <param name="slice">Packed representation</param>
            <returns>Deserialized <typeparamref name="T"/> instance.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbOrderedKeyEncoder`1.EncodeOrdered(`0)">
            <summary>Encode a <typeparamref name="T"/> into a standalone slice</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbOrderedKeyEncoder`1.DecodeOrdered(FoundationDB.Client.Slice)">
            <summary>Decode a standoline slice - previously encoded via a call to <see cref="!:Encode"/>- into a <typeparamref name="T"/></summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbOrderedKeyEncoder`1.EncodeOrderedPart(FoundationDB.Client.Utils.SliceWriter@,`0)">
            <summary>Append a <typeparamref name="T"/> at the end of a composite key</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbOrderedKeyEncoder`1.DecodeOrderedPart(FoundationDB.Client.SliceReader@)">
            <summary>Read a <typeparamref name="T"/> from a composite key</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabasePartition">
            <summary>Database instance that manages the content of a KeySpace partition</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabasePartition.m_root">
            <summary>Root directory layer</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabasePartition.Root">
            <summary>DirectoryLayer instance corresponding to the Root of this partition</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbSubspace">
            <summary>Adds a prefix on every keys, to group them inside a common subspace</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbSubspace.Empty">
            <summary>Empty subspace, that does not add any prefix to the keys</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbSubspace.m_rawPrefix">
            <summary>Binary prefix of this subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.#ctor(FoundationDB.Client.Slice)">
            <summary>Create a new subspace from a binary prefix</summary>
            <param name="rawPrefix">Prefix of the new subspace</param>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.#ctor(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a new subspace from a Tuple prefix</summary>
            <param name="tuple">Tuple packed to produce the prefix</param>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Partition``1(``0)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T">Type of the child subspace key</typeparam>
            <param name="value">Value of the child subspace</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <remarks>Subspace([Foo, ]).Partition(Bar) is equivalent to Subspace([Foo, Bar, ])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition("Contacts") == new FdbSubspace(["Users", "Contacts", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Partition``2(``0,``1)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T1">Type of the primary subspace key</typeparam>
            <typeparam name="T2">Type of the secondary subspace key</typeparam>
            <param name="value1">Value of the primary subspace key</param>
            <param name="value1">Value of the secondary subspace key</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <remarks>Subspace([Foo, ]).Partition(Bar, Baz) is equivalent to Subspace([Foo, Bar, Baz])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition("Contacts", "Friends") == new FdbSubspace(["Users", "Contacts", "Friends", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Partition``3(``0,``1,``2)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T1">Type of the primary subspace key</typeparam>
            <typeparam name="T2">Type of the secondary subspace key</typeparam>
            <typeparam name="T2">Type of the tertiary subspace key</typeparam>
            <param name="value1">Value of the primary subspace key</param>
            <param name="value1">Value of the secondary subspace key</param>
            <param name="value1">Value of the tertiary subspace key</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <example>
            new FdbSubspace(["Users", ]).Partition("John Smith", "Contacts", "Friends") == new FdbSubspace(["Users", "John Smith", "Contacts", "Friends", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Partition(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Parition this subspace by appending a tuple</summary>
            <param name="tuple">Tuple that will be used for this partition</param>
            <returns>New subspace that is creating by combining the namespace prefix and <paramref name="tuple"/></returns>
            <remarks>Subspace([Foo, ]).Partition([Bar, Baz, ]) is equivalent to Subspace([Foo, Bar, Baz,])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition(["Contacts", "Friends", ]) => new FdbSubspace(["Users", "Contacts", "Friends", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Partition(FoundationDB.Layers.Tuples.ITupleFormattable)">
            <summary>Partition this subspace into a child subspace</summary>
            <param name="formattable">a ITupleFormattable, <paramref name="formattable"/>.ToTuple() will be used for this partition</param>
            <returns>New subspace that is creating by combining the namespace prefix and <paramref name="formattable"/></returns>
            <remarks>Subspace([Foo, ]).Partition(Bar) is equivalent to Subspace([Foo, Bar, ])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition("Contacts") == new FdbSubspace(["Users", "Contacts", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Contains(FoundationDB.Client.Slice)">
            <summary>Returns true if <paramref name="key"/> is contained withing this subspace's tuple (or is equal to tuple itself)</summary>
            <remarks>The key Slice.Nil is not contained by any subspace, so subspace.Contains(Slice.Nil) will always return false</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.PackBoxed(System.Object)">
            <summary>Create a new key by appending a value to the current tuple</summary>
            <param name="key">Value that will be appended at the end of the key</param>
            <returns>Key the correspond to the concatenation of the current tuple and <paramref name="key"/></returns>
            <example>tuple.PackBoxed(x) is the non-generic equivalent of tuple.Pack&lt;object&gt;(tuple)</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Pack``1(``0)">
            <summary>Create a new key by appending a value to the current tuple</summary>
            <typeparam name="T">Type of the value</typeparam>
            <param name="key">Value that will be appended at the end of the key</param>
            <returns>Key the correspond to the concatenation of the current tuple and <paramref name="key"/></returns>
            <example>tuple.Pack(x) is equivalent to tuple.Append(x).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Pack``2(``0,``1)">
            <summary>Create a new key by appending two values to the current tuple</summary>
            <typeparam name="T1">Type of the next to last value</typeparam>
            <typeparam name="T2">Type of the last value</typeparam>
            <param name="key1">Value that will be in the next to last position</param>
            <param name="key2">Value that will be in the last position</param>
            <returns>Key the correspond to the concatenation of the current tuple, <paramref name="key1"/> and <paramref name="key2"/></returns>
            <example>(...,).Pack(x, y) is equivalent to (...,).Append(x).Append(y).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Pack``3(``0,``1,``2)">
            <summary>Create a new key by appending three values to the current tuple</summary>
            <typeparam name="T1">Type of the first value</typeparam>
            <typeparam name="T2">Type of the second value</typeparam>
            <typeparam name="T3">Type of the thrid value</typeparam>
            <param name="key1">Value that will be appended first</param>
            <param name="key2">Value that will be appended second</param>
            <param name="key3">Value that will be appended third</param>
            <returns>Key the correspond to the concatenation of the current tuple, <paramref name="key1"/>, <paramref name="key2"/> and <paramref name="key3"/></returns>
            <example>tuple.Pack(x, y, z) is equivalent to tuple.Append(x).Append(y).Append(z).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Pack``4(``0,``1,``2,``3)">
            <summary>Create a new key by appending three values to the current tuple</summary>
            <typeparam name="T1">Type of the first value</typeparam>
            <typeparam name="T2">Type of the second value</typeparam>
            <typeparam name="T3">Type of the third value</typeparam>
            <typeparam name="T4">Type of the fourth value</typeparam>
            <param name="key1">Value that will be appended first</param>
            <param name="key2">Value that will be appended second</param>
            <param name="key3">Value that will be appended third</param>
            <param name="key4">Value that will be appended fourth</param>
            <returns>Key the correspond to the concatenation of the current tuple, <paramref name="key1"/>, <paramref name="key2"/>, <paramref name="key3"/> and <paramref name="key4"/></returns>
            <example>tuple.Pack(w, x, y, z) is equivalent to tuple.Append(w).Append(x).Append(y).Append(z).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Merge(System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Merge a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Merge(FoundationDB.Client.Slice[])">
            <summary>Merge an array of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="keys">Array of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.PackRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Merge a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.PackRange``1(``0[])">
            <summary>Merge a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.PackBoxedRange(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Pack a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.PackBoxedRange(System.Object[])">
            <summary>Pack a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.ToTuple">
            <summary>Return an empty tuple that is attached to this subspace</summary>
            <returns>Empty tuple that can be extended, and whose packed representation will always be prefixed by the subspace key</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Append(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Attach a tuple to an existing subspace.</summary>
            <param name="value">Tuple whose items will be appended at the end of the current subspace</param>
            <returns>Tuple that wraps the items of <param name="tuple"/> and whose packed representation will always be prefixed by the subspace key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Append(FoundationDB.Layers.Tuples.ITupleFormattable)">
            <summary>Convert a formattable item into a tuple that is attached to this subspace.</summary>
            <param name="formattable">Item that can be converted into a tuple</param>
            <returns>Tuple that is the logical representation of the item, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(formattable.ToTuple())'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Append``1(``0)">
            <summary>Create a new 1-tuple that is attached to this subspace</summary>
            <typeparam name="T">Type of the value to append</typeparam>
            <param name="value">Value that will be appended</param>
            <returns>Tuple of size 1 that contains <paramref name="value"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T&gt;(value))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Append``2(``0,``1)">
            <summary>Create a new 2-tuple that is attached to this subspace</summary>
            <typeparam name="T1">Type of the first value to append</typeparam>
            <typeparam name="T2">Type of the second value to append</typeparam>
            <param name="value1">First value that will be appended</param>
            <param name="value2">Second value that will be appended</param>
            <returns>Tuple of size 2 that contains <paramref name="value1"/> and <paramref name="value2"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T1, T2&gt;(value1, value2))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Append``3(``0,``1,``2)">
            <summary>Create a new 3-tuple that is attached to this subspace</summary>
            <typeparam name="T1">Type of the first value to append</typeparam>
            <typeparam name="T2">Type of the second value to append</typeparam>
            <typeparam name="T3">Type of the third value to append</typeparam>
            <param name="value1">First value that will be appended</param>
            <param name="value2">Second value that will be appended</param>
            <param name="value3">Third value that will be appended</param>
            <returns>Tuple of size 3 that contains <paramref name="value1"/>, <paramref name="value2"/> and <paramref name="value3"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T1, T2, T3&gt;(value1, value2, value3))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Append(System.Object[])">
            <summary>Create a new N-tuple that is attached to this subspace</summary>
            <param name="items">Array of items of the new tuple</param>
            <returns>Tuple of size <paramref name="items"/>.Length, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create(items))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Unpack(FoundationDB.Client.Slice)">
            <summary>Unpack a key into a tuple, with the subspace prefix removed</summary>
            <param name="key">Packed version of a key that should fit inside this subspace.</param>
            <returns>Unpacked tuple that are relative to the current subspace, or null if the key is equal to Slice.Nil</returns>
            <example>new Subspace([FE]).Unpack([FE 02 'H' 'e' 'l' 'l' 'o' 00 15 1]) =&gt; ("hello", 1,)</example>
            <exception cref="T:System.ArgumentOutOfRangeException">If the unpacked tuple is not contained in this subspace</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.UnpackLast``1(FoundationDB.Client.Slice)">
            <summary>Unpack a key into a tuple, and return only the last element</summary>
            <typeparam name="T">Expected type of the last element</typeparam>
            <param name="key">Packed version of a key that should fit inside this subspace</param>
            <returns>Converted value of the last element of the tuple</returns>
            <example>new Subspace([FE]).UnpackLast&lt;int&gt;([FE 02 'H' 'e' 'l' 'l' 'o' 00 15 1]) => (int) 1</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.UnpackSingle``1(FoundationDB.Client.Slice)">
            <summary>Unpack a key into a singleton tuple, and return the single element</summary>
            <typeparam name="T">Expected type of the only element</typeparam>
            <param name="key">Packed version of a key that should fit inside this subspace</param>
            <returns>Converted value of the only element in the tuple. Throws an exception if the tuple is empty or contains more than one element</returns>
            <example>new Subspace([FE]).UnpackSingle&lt;int&gt;([FE 02 'H' 'e' 'l' 'l' 'o' 00]) => (string) "Hello"</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Unpack(FoundationDB.Client.Slice[])">
            <summary>Unpack an array of keys in tuples, with the subspace prefix removed</summary>
            <param name="keys">Packed version of keys inside this subspace</param>
            <returns>Unpacked tuples that are relative to the current subspace</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.UnpackLast``1(FoundationDB.Client.Slice[])">
            <summary>Unpack an array of key into tuples, and return an array with only the last elements of each tuple</summary>
            <typeparam name="T">Expected type of the last element of all the keys</typeparam>
            <param name="keys">Array of packed keys that should all fit inside this subspace</param>
            <returns>Array containing the converted values of the last elements of each tuples</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.UnpackSingle``1(FoundationDB.Client.Slice[])">
            <summary>Unpack an array of key into singleton tuples, and return an array with value of each tuple</summary>
            <typeparam name="T">Expected type of the only element of all the keys</typeparam>
            <param name="keys">Array of packed keys that should all fit inside this subspace</param>
            <returns>Array containing the converted values of the only elements of each tuples. Throws an exception if one key contains more than one element</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice)">
            <summary>Append a key to the subspace key</summary>
            <remarks>This is the equivalent of calling 'subspace.Key + key'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Append a pair of keys to the subspace key</summary>
            <remarks>This is the equivalent of calling 'subspace.Key + key1 + key2'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice[])">
            <summary>Append a batch of keys to the subspace key</summary>
            <param name="keys">Array of key suffix</param>
            <returns>Array of keys each prefixed by the subspace key</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Extract(FoundationDB.Client.Slice)">
            <summary>Remove the subspace prefix from a binary key, and only return the tail, or Slice.Nil if the key does not fit inside the namespace</summary>
            <param name="key">Complete key that contains the current subspace prefix, and a binary suffix</param>
            <returns>Binary suffix of the key (or Slice.Empty is the key is exactly equal to the subspace prefix). If the key is outside of the subspace, returns Slice.Nil</returns>
            <remarks>This is the inverse operation of <see cref="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice)"/></remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Extract(FoundationDB.Client.Slice[])">
            <summary>Remove the subspace prefix from a batch of binary keys, and only return the tail, or Slice.Nil if a key does not fit inside the namespace</summary>
            <param name="keys">Array of complete keys that contains the current subspace prefix, and a binary suffix</param>
            <returns>Array of only the binary suffix of the keys, Slice.Empty for a key that is exactly equal to the subspace prefix, or Slice.Nil for a key that is outside of the subspace</returns>
            <remarks>This is the inverse operation of <see cref="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice[])"/></remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.BoundCheck(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Check that a key fits inside this subspace, and return '' or '\xFF' if it is outside the bounds</summary>
            <param name="key">Key that needs to be checked</param>
            <param name="allowSystemKeys">If true, allow keys that starts with \xFF even if this subspace is not the Empty subspace or System subspace itself.</param>
            <returns>The key will return unchanged if it is contained in the namespace, Slice.Empty if it was before, or FdbKey.MaxValue if it was after.</returns>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.Key">
            <summary>Returns the binary prefix of this subspace</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.Item(FoundationDB.Client.Slice)">
            <summary>Create a new subspace of the current subspace</summary>
            <param name="suffix">Binary suffix that will be appended to the current prefix</param>
            <returns>New subspace whose prefix is the concatenation of the parent prefix, and <paramref name="suffix"/></returns>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.Item(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a new subspace of the current subspace</summary>
            <param name="tuple">Binary suffix that will be appended to the current prefix</param>
            <returns>New subspace whose prefix is the concatenation of the parent prefix, and <paramref name="suffix"/></returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CheckLayer(System.String)">
            <summary>Ensure that this directory was registered with the correct layer id</summary>
            <param name="layer">Expected layer id (if not empty)</param>
            <exception cref="T:System.InvalidOperationException">If the directory was registerd with a different layer id</exception>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ChangeLayerAsync(FoundationDB.Client.IFdbTransaction,System.String)">
            <summary>Change the layer id of this directory</summary>
            <param name="newLayer">New layer id of this directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given path.
            If the subdirectory does not exist, it is created (creating intermediate subdirectories if necessary).
            If prefix is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If layer is specified, it is checked against the layer of an existing subdirectory or set as the layer of a new subdirectory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String,FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given path.
            If the subdirectory does not exist, it is created (creating intermediate subdirectories if necessary).
            If prefix is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.
            If layer is specified, it is checked against the layer of an existing subdirectory or set as the layer of a new subdirectory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.OpenAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory does not exist, or if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.OpenAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory does not exist, or if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryOpenAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory does not exist, or if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryOpenAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory does not exist, or if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CreateAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CreateAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String,FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryCreateAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryCreateAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String,FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the subdirectory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.MoveAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Moves the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
            <param name="newPath">Full path (from the root) where this directory will be moved</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.MoveAsync(FoundationDB.Client.IFdbTransaction,System.String[])">
            <summary>Moves the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newPath">Full path (from the root) where this directory will be moved</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryMoveAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Attempts to move the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
            <param name="newPath">Full path (from the root) where this directory will be moved</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryMoveAsync(FoundationDB.Client.IFdbTransaction,System.String[])">
            <summary>Attempts to move the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newPath">Full path (from the root) where this directory will be moved</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.RemoveAsync(FoundationDB.Client.IFdbTransaction)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryRemoveAsync(FoundationDB.Client.IFdbTransaction)">
            <summary>Attempts to remove the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Checks if this directory exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Returns the list of all the subdirectories of the current directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Returns the list of all the subdirectories of the current directory, it it exists.</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.Path">
            <summary>Path of this directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.Layer">
            <summary>Layer id of this directory</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbHighContentionAllocator.AllocateAsync(FoundationDB.Client.IFdbTransaction)">
            <summary>Returns a 64-bit integer that
            1) has never and will never be returned by another call to this
               method on the same subspace
            2) is nearly as short as possible given the above
            </summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbHighContentionAllocator.Subspace">
            <summary>Location of the allocator</summary>
        </member>
        <member name="T:FoundationDB.Layers.Directories.FdbDirectoryLayer">
            <summary>Provides a FdbDirectoryLayer class for managing directories in FoundationDB.
            Directories are a recommended approach for administering layers and applications. Directories work in conjunction with subspaces. Each layer or application should create or open at least one directory with which to manage its subspace(s).
            Directories are identified by paths (specified as tuples) analogous to the paths in a Unix-like file system. Each directory has an associated subspace that is used to store content. The layer uses a high-contention allocator to efficiently map each path to a short prefix for its corresponding subspace.
            <see cref="!:FdbDirectorLayer"/> exposes methods to create, open, move, remove, or list directories. Creating or opening a directory returns the corresponding subspace.
            The <see cref="T:FoundationDB.Layers.Directories.FdbDirectorySubspace"/> class represents subspaces that store the contents of a directory. An instance of <see cref="T:FoundationDB.Layers.Directories.FdbDirectorySubspace"/> can be used for all the usual subspace operations. It can also be used to operate on the directory with which it was opened.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.#ctor(FoundationDB.Client.FdbSubspace,FoundationDB.Client.FdbSubspace)">
            <summary>
            Creates a new instance that will manages directories in FoudnationDB.
            </summary>
            <param name="nodeSubspace">Subspace where all the node metadata will be stored ('\xFE' by default)</param>
            <param name="contentSubspace">Subspace where all automatically allocated directories will be stored (empty by default)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice)">
            <summary>Opens the directory with the given path. If the directory does not exist, it is created (creating parent directories if necessary).</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create or open</param>
            <param name="layer">If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.</param>
            <param name="prefix">If a prefix is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically inside then Content subspace.</param>
            <param name="allowCreate">If the directory does not exist, it will be created if <paramref name="allowCreate"/> is true, or an exception will be thrown if it is false</param>
            <param name="allowOpen">If the directory already exists, it will be opened if <paramref name="allowOpen"/> is true, or an exception will be thrown if it is false</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String,FoundationDB.Client.Slice)">
            <summary>Opens the directory with the given path. If the directory does not exist, it is created (creating parent directories if necessary).</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create or open</param>
            <param name="layer">If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.</param>
            <param name="prefix">If a prefix is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically inside then Content subspace.</param>
            <param name="allowCreate">If the directory does not exist, it will be created if <paramref name="allowCreate"/> is true, or an exception will be thrown if it is false</param>
            <param name="allowOpen">If the directory already exists, it will be opened if <paramref name="allowOpen"/> is true, or an exception will be thrown if it is false</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.OpenAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An exception is thrown if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to open.</param>
            <param name="layer">Optional layer id of the directory. If it is different than the layer specified when creating the directory, an exception will be thrown.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.OpenAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An exception is thrown if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to open.</param>
            <param name="layer">Optional layer id of the directory. If it is different than the layer specified when creating the directory, an exception will be thrown.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.CreateAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An exception is thrown if the given directory already exists.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.CreateAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String,FoundationDB.Client.Slice)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An exception is thrown if the given directory already exists.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryOpenAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to open.</param>
            <param name="layer">Optional layer id of the directory. If it is different than the layer specified when creating the directory, an exception will be thrown.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryOpenAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to open.</param>
            <param name="layer">Optional layer id of the directory. If it is different than the layer specified when creating the directory, an exception will be thrown.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryCreateAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String,FoundationDB.Client.Slice)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryCreateAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String,FoundationDB.Client.Slice)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
            <param name="prefix">If <paramref name="prefix"/> is specified, the directory is created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.MoveAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Moves the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Path of the directory to move</param>
            <param name="newPath">New path of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryMoveAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Attempts to move the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            Returns null if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Path of the directory to move</param>
            <param name="newPath">New path of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.MoveAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String[])">
            <summary>Moves the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Path of the directory to move</param>
            <param name="newPath">New path of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryMoveAsync(FoundationDB.Client.IFdbTransaction,System.String[],System.String[])">
            <summary>Attempts to move the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            Returns null if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Path of the directory to move</param>
            <param name="newPath">New path of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryRemoveAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveAsync(FoundationDB.Client.IFdbTransaction,System.String[])">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryRemoveAsync(FoundationDB.Client.IFdbTransaction,System.String[])">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Checks if a directory already exists</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.String[])">
            <summary>Checks if a directory already exists</summary>
            <param name="tr">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/></summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.String[])">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/></summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>, if it exists.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.String[])">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>, if it exists.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ChangeLayerInternalAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple,System.String)">
            <summary>Change the layer id of this directory</summary>
            <param name="newLayer">New layer id of this directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.NodeWithPrefix(FoundationDB.Client.Slice)">
            <summary>Returns the subspace to a node metadata, given its prefix</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ContentsOfNode(FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple,System.String)">
            <summary>Returns a new Directory Subspace given its node subspace, path and layer id</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.Find(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Finds a node subspace, given its path, by walking the tree from the root</summary>
            <returns>Node if it was found, or null</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.SubdirNamesAndNodes(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbSubspace)">
            <summary>Returns the list of names and nodes of all children of the specified node</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveFromParent(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Remove an existing node from its parents</summary>
            <returns>True if the parent node was found, otherwise false</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveRecursive(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbSubspace)">
            <summary>Resursively remove a node (including the content), all its children</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.ContentSubspace">
            <summary>Subspace where the content of each folder will be stored</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.NodeSubspace">
            <summary>Subspace where all the metadata nodes for each folder will be stored</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.RootNode">
            <summary>Root node of the directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.Allocator">
            <summary>Allocated used to generated prefix for new content</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbSubspaceTuple">
            <summary>Tuple that is rooted under an existing subspace (that can have an arbitrary binary prefix)</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.IFdbTuple">
            <summary>Represents a Tuple of N elements</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.Get``1(System.Int32)">
            <summary>Return the typed value of an item of the tuple, given its position</summary>
            <typeparam name="T">Expected type of the item</typeparam>
            <param name="index">Position of the item (if negative, means relative from the end)</param>
            <returns>Value of the item at position <paramref name="index"/>, adapted into type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is outside the bounds of the tuple</exception>
            <example>
            ("Hello", "World", 123,).Get&lt;string&gt;(0) =&gt; "Hello"
            ("Hello", "World", 123,).Get&lt;int&gt;(-1) =&gt; 123
            ("Hello", "World", 123,).Get&lt;string&gt;(-1) =&gt; "123"
            </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.Last``1">
            <summary>Return the typed value of the last item in the tuple</summary>
            <typeparam name="T">Expected type of the item</typeparam>
            <returns>Value of the last item of this tuple, adapted into type <typeparamref name="T"/></returns>
            <remarks>Equivalent of tuple.Get&lt;T&gt;(-1)</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.Append``1(``0)">
            <summary>Create a new Tuple by appending a new value at the end the this tuple</summary>
            <typeparam name="T">Type of the new value</typeparam>
            <param name="value">Value that will be appended at the end</param>
            <returns>New tuple with the new value</returns>
            <example>("Hello,").Append("World") => ("Hello", "World",)</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.CopyTo(System.Object[],System.Int32)">
            <summary>Copy all items of the tuple into an array at a specific location</summary>
            <param name="array">Destination array (must be big enough to contains all the items)</param>
            <param name="offset">Offset at wich to start copying items</param>
            <example>
            var tmp = new object[3];
            ("Hello", "World", 123,).CopyTo(tmp, 0);
            </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.PackTo(FoundationDB.Client.Utils.SliceWriter@)">
            <summary>Appends the packed bytes of this instance to the end of a buffer</summary>
            <param name="writer">Buffer that will received the packed bytes of this instance</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.ToSlice">
            <summary>Pack this instance into a Slice</summary>
            <example>
            ("Hello", "World", 123).ToSlice() => '\x02Hello\x00\x02World\x00\x15\x7B'
            </example>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.IFdbTuple.Item(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Return a section of the tuple</summary>
            <param name="from">Starting offset of the sub-tuple to return, or null to select from the start. Negative values means from the end</param>
            <param name="to">Ending offset of the sub-tuple to return or null to select until the end. Negative values means from the end</param>
            <returns>Tuple that only includes the selected items</returns>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.FdbSubspaceTuple.Subspace">
            <summary>Parent subspace that created this tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleAlias">
            <summary>Special tuple values</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleAlias.Zero">
            <summary>Alias that represents the Null or Min value '\0' when used in the last position.</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleAlias.Directory">
            <summary>Alias that represents the value '\xFE', frequently used by the Directory Layer</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleAlias.System">
            <summary>Alias that represents the Max value '\xFF', also used by the System Keys when in the first position</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbAnonymousTupleFormatter`1">
            <summary>Customer formatter that will called the provided lambda functions to convert to and from a tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.ITupleFormatter`1">
            <summary>
            Defines methods to support converting keys into/from tuples
            </summary>
            <typeparam name="TKey">Type of the keys</typeparam>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormatter`1.ToTuple(`0)">
            <summary>Convert a key into a tuple sequence</summary>
            <param name="key">Key to convert to a tuple</param>
            <returns>Tuple that represent the key (can contain a single item for primitive keys, or several items for composite keys)</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormatter`1.FromTuple(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Convert a tuple sequence into a key</summary>
            <param name="tuple">Tuple to convert back into a key</param>
            <returns>Key that corresponds to the tuple</returns>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbGenericTupleFormatter`1">
            <summary>Simple key formatter that maps a value into a singleton tuple, and back</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbFormattableTupleFormatter`1">
            <summary>Specialized formatter for types that implement ITupleFormattable</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.ITupleFormattable">
            <summary>
            Defines a generalized method to convert a custom type into a tuple and back
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormattable.ToTuple">
            <summary>Return the tuple representation of this instance</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormattable.FromTuple(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Load a tuple representation into a newly created instance</summary>
            <param name="tuple"></param>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleComparisons">
            <summary>Helper class for tuple comparisons</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleComparisons.Default">
            <summary>Tuple comparer that treats similar values as equal ("123" = 123 = 123L = 123.0d)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleComparisons.Bcl">
            <summary>Tuple comparer that uses the default BCL object comparison ("123" != 123 != 123L != 123.0d)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleComparisons.Binary">
            <summary>Tuple comparer that compared the packed bytes (slow!)</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbJoinedTuple">
            <summary>Tuple that represents the concatenation of two tuples</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.Head">
            <summary>First tuple (first N items)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.Tail">
            <summary>Second tuple (last M items)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.m_split">
            <summary>Offset at which the Tail tuple starts. Items are in Head tuple if index &lt; split. Items are in Tail tuple if index &gt;= split.</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.m_count">
            <summary>Total size of the tuple (sum of the size of the two inner tuples)</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbSubspaceExtensions">
            <summary>Extensions methods to add FdbSubspace overrides to various types</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ClearRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbSubspace)">
            <summary>Clear the entire content of a subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ClearRangeAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>Clear the entire content of a subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.GetRangeStartsWith(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbSubspace,FoundationDB.Client.FdbRangeOptions)">
            <summary>Returns all the keys inside of a subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.GetAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Read a key inside a subspace</summary>
            <example>
            Both lines are equivalent:
            tr.GetAsync(new FdbSubspace("Hello"), FdbTuple.Create("World"));
            tr.GetAsync(FdbTuple.Create("Hello", "World"));
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Set(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Client.Slice)">
            <summary>Write a key inside a subspace</summary>
            <example>
            Both lines are equivalent:
            tr.Set(new FdbSubspace("Hello"), FdbTuple.Create("World"), some_value);
            tr.Set(FdbTuple.Create("Hello", "World"), some_value);
            </example>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbLinkedTuple`1">
            <summary>Tuple that adds a value at the end of an already existing tuple</summary>
            <typeparam name="T">Type of the last value of the tuple</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Tail">
            <summary>Value of the last element of the tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Head">
            <summary>Link to the parent tuple that contains the head.</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Depth">
            <summary>Cached size of the size of the Head tuple. Add 1 to get the size of this tuple.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.#ctor(FoundationDB.Layers.Tuples.IFdbTuple,`0)">
            <summary>Append a new value at the end of an existing tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.PackTo(FoundationDB.Client.Utils.SliceWriter@)">
            <summary>Pack this tuple into a buffer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.ToSlice">
            <summary>Pack this tuple into a slice</summary>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Count">
            <summary>Returns the number of elements in this tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple">
            <summary>Factory class for Tuples</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple.Empty">
            <summary>Empty tuple</summary>
            <remarks>Not to be mistaken with a 1-tuple containing 'null' !</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateBoxed(System.Object)">
            <summary>Create a new 1-tuple, holding only one item</summary>
            <remarks>This is the non-generic equivalent of FdbTuple.Create&lt;object&gt;()</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``1(``0)">
            <summary>Create a new 1-tuple, holding only one item</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``2(``0,``1)">
            <summary>Create a new 2-tuple, holding two items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``3(``0,``1,``2)">
            <summary>Create a new 3-tuple, holding three items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create(System.Object[])">
            <summary>Create a new N-tuple, from N items</summary>
            <param name="items">Items to wrap in a tuple</param>
            <remarks>If you already have an array of items, you should call <see cref="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Object[])"/> instead. Mutating the array, would also mutate the tuple!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Wrap(System.Object[])">
            <summary>Create a new N-tuple that wraps an array of untyped items</summary>
            <remarks>If the original array is mutated, the tuple will reflect the changes!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Wrap(System.Object[],System.Int32,System.Int32)">
            <summary>Create a new N-tuple that wraps a section of an array of untyped items</summary>
            <remarks>If the original array is mutated, the tuple will reflect the changes!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Object[])">
            <summary>Create a new N-tuple, from an array of untyped items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Object[],System.Int32,System.Int32)">
            <summary>Create a new N-tuple, from a section of an array of untyped items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Create a new N-tuple from a sequence of items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange``1(``0[])">
            <summary>Create a new N-tuple, from an array of typed items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange``1(``0[],System.Int32,System.Int32)">
            <summary>Create a new N-tuple, from a section of an array of typed items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Create a new N-tuple from a sequence of typed items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxed(System.Object)">
            <summary>Pack a 1-tuple directly into a slice</summary>
            <remarks>This is the non-generic equivalent of FdbTuple.Pack&lt;object&gt;()</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``1(``0)">
            <summary>Pack a 1-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``2(``0,``1)">
            <summary>Pack a 2-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``3(``0,``1,``2)">
            <summary>Pack a 3-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``4(``0,``1,``2,``3)">
            <summary>Pack a 4-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{``0})">
            <summary>Merge a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Client.Slice,``0[])">
            <summary>Merge a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange(System.Collections.Generic.IEnumerable{FoundationDB.Layers.Tuples.IFdbTuple})">
            <summary>Pack a sequence of N-tuples, all sharing the same buffer</summary>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack([ ("Foo", 1), ("Foo", 2) ]) => [ "\x02Foo\x00\x15\x01", "\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange(FoundationDB.Layers.Tuples.IFdbTuple[])">
            <summary>Pack a sequence of N-tuples, all sharing the same buffer</summary>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack([ ("Foo", 1), ("Foo", 2) ]) => [ "\x02Foo\x00\x15\x01", "\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Layers.Tuples.IFdbTuple,System.Collections.Generic.IEnumerable{``0})">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Layers.Tuples.IFdbTuple,``0[])">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Client.Slice,System.Object[])">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Layers.Tuples.IFdbTuple,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Layers.Tuples.IFdbTuple,System.Object[])">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Unpack(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from a serialied key blob</summary>
            <param name="packedKey">Binary key containing a previously packed tuple</param>
            <returns>Unpacked tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackWithoutPrefix(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from a serialized key, after removing the prefix</summary>
            <param name="packedKey">Packed key</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Unpacked tuple (minus the prefix) or an exception if the key is outside the prefix</returns>
            <exception cref="T:System.ArgumentNullException">If prefix is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the unpacked key is outside the specified prefix</exception>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackLast``1(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple and only return its last element</summary>
            <typeparam name="T">Type of the last value in the decoded tuple</typeparam>
            <param name="packedKey">Slice that should be entirely parsable as a tuple</param>
            <returns>Decoded value of the last item in the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackLastWithoutPrefix``1(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack a tuple and only return its last element, after removing <paramref name="prefix"/> from the start of the buffer</summary>
            <typeparam name="T">Type of the last value in the decoded tuple</typeparam>
            <param name="packedKey">Slice composed of <paramref name="prefix"/> followed by a packed tuple</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Decoded value of the last item in the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackSingle``1(FoundationDB.Client.Slice)">
            <summary>Unpack the value of a singletion tuple</summary>
            <typeparam name="T">Type of the single value in the decoded tuple</typeparam>
            <param name="packedKey">Slice that should contain the packed representation of a tuple with a single element</param>
            <returns>Decoded value of the only item in the tuple. Throws an exception if the tuple is empty of has more than one element.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackSingleWithoutPrefix``1(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack the value of a singleton tuple, after removing <paramref name="prefix"/> from the start of the buffer</summary>
            <typeparam name="T">Type of the single value in the decoded tuple</typeparam>
            <param name="packedKey">Slice composed of <paramref name="prefix"/> followed by a packed singleton tuple</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Decoded value of the only item in the tuple. Throws an exception if the tuple is empty of has more than one element.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Concat(FoundationDB.Client.Slice,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Efficiently concatenate a prefix with the packed representation of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ConcatBoxed(FoundationDB.Client.Slice,System.Object)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 1-tuple</summary>
            <remarks>This is the non-generic equivalent of FdbTuple.Concat&lt;object&gt;()</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Concat``1(FoundationDB.Client.Slice,``0)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 1-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Concat``2(FoundationDB.Client.Slice,``0,``1)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 2-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Concat``3(FoundationDB.Client.Slice,``0,``1,``2)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 3-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Concat``4(FoundationDB.Client.Slice,``0,``1,``2,``3)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 4-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToRange(FoundationDB.Client.Slice)">
            <summary>Create a range that selects all tuples that are stored under the specified subspace: 'prefix\x00' &lt;= k &lt; 'prefix\xFF'</summary>
            <param name="prefix">Subspace binary prefix (that will be excluded from the range)</param>
            <returns>Range including all possible tuples starting with the specified prefix.</returns>
            <remarks>FdbTuple.ToRange(Slice.FromAscii("abc")) returns the range [ 'abc\x00', 'abc\xFF' )</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToRange(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>
            Create a range that selects all the tuples of greater length than the specified <paramref name="tuple"/>, and that start with the specified elements: packed(tuple)+'\x00' &lt;= k &lt; packed(tuple)+'\xFF'
            </summary>
            <example>FdbTuple.ToRange(FdbTuple.Create("a", "b")) includes all tuples ("a", "b", ...), but not the tuple ("a", "b") itself.</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Stringify(System.Object)">
            <summary>Converts any object into a displayble string, for logging/debugging purpose</summary>
            <param name="item">Object to stringify</param>
            <returns>String representation of the object</returns>
            <example>
            Stringify(null) => "nil"
            Stringify("hello") => "\"hello\""
            Stringify(123) => "123"
            Stringify(123.4) => "123.4"
            Stringify(true) => "true"
            Stringify(Slice) => hexa decimal string ("01 23 45 67 89 AB CD EF")
            </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToString(System.Object[],System.Int32,System.Int32)">
            <summary>Convert a list of object into a displaying string, for loggin/debugging purpose</summary>
            <param name="items">Array containing items to stringfy</param>
            <param name="offset">Start offset of the items to convert</param>
            <param name="count">Number of items to convert</param>
            <returns>String representation of the tuple in the form "(item1, item2, ... itemN,)"</returns>
            <example>ToString(FdbTuple.Create("hello", 123, true, "world")) => "(\"hello\", 123, true, \"world\",)</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToString(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Convert a sequence of object into a displaying string, for loggin/debugging purpose</summary>
            <param name="items">Sequence of items to stringfy</param>
            <returns>String representation of the tuple in the form "(item1, item2, ... itemN,)"</returns>
            <example>ToString(FdbTuple.Create("hello", 123, true, "world")) => "(\"hello\", 123, true, \"world\",)</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Splice(FoundationDB.Layers.Tuples.IFdbTuple,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Default (non-optimized) implementation of IFdbTuple.this[long?, long?]</summary>
            <param name="tuple">Tuple to slice</param>
            <param name="from">Start offset of the section (included)</param>
            <param name="to">End offset of the section (included)</param>
            <returns>New tuple only containing items inside this section</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.StartsWith(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Default (non-optimized) implementation for IFdbTuple.StartsWith()</summary>
            <param name="a">Larger tuple</param>
            <param name="b">Smaller tuple</param>
            <returns>True if <paramref name="a"/> starts with (or is equal to) <paramref name="b"/></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CopyTo(FoundationDB.Layers.Tuples.IFdbTuple,System.Object[],System.Int32)">
            <summary>Helper to copy the content of a tuple at a specific position in an array</summary>
            <returns>Updated offset just after the last element of the copied tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.MapIndex(System.Int32,System.Int32,System.Boolean)">
            <summary>Maps a relative index into an absolute index</summary>
            <param name="index">Relative index in the tuple (from the end if negative)</param>
            <param name="count">Size of the tuple</param>
            <returns>Absolute index from the start of the tuple, or exception if outside of the tuple</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the absolute index is outside of the tuple (&lt;0 or &gt;=<paramref name="count"/>)</exception>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.MapIndexBounded(System.Int32,System.Int32)">
            <summary>Maps a relative index into an absolute index</summary>
            <param name="index">Relative index in the tuple (from the end if negative)</param>
            <param name="count">Size of the tuple</param>
            <returns>Absolute index from the start of the tuple, or exception if outside of the tuple</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the absolute index is outside of the tuple (&lt;0 or &gt;=<paramref name="count"/>)</exception>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple.EmptyTuple">
            <summary>Empty tuple (singleton that is used as a base for other tuples)</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessThan(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the last key that is less than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessOrEqual(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the last key that is less than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterThan(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the first key that is greater than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterOrEqual(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the first key that is greater than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessThan``1(``0)">
            <summary>Creates a key selector that will select the last key that is less than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessOrEqual``1(``0)">
            <summary>Creates a key selector that will select the last key that is less than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterThan``1(``0)">
            <summary>Creates a key selector that will select the first key that is greater than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterOrEqual``1(``0)">
            <summary>Creates a key selector that will select the first key that is greater than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.op_Addition(FoundationDB.Client.FdbKeySelector,System.Int32)">
            <summary>Add a value to the selector's offset</summary>
            <param name="selector">ex: fGE('abc')</param>
            <param name="offset">ex: 7</param>
            <returns>fGE('abc')+7</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabase">
            <summary>FoundationDB Database</summary>
            <remarks>Wraps an FDBDatabase* handle</remarks>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_cluster">
            <summary>Parent cluster that owns the database.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_handle">
            <summary>Handle that wraps the native FDB_DATABASE*</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_name">
            <summary>Name of the database (note: value it is the value that was passed to Connect(...) since we don't have any API to read the name from an FDB_DATABASE* handle)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_ownsCluster">
            <summary>If true, the cluster instance will be disposed at the same time as the current db instance.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_readOnly">
            <summary>If true, the database will only allow read-only transactions.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_cts">
            <summary>Global cancellation source that is cancelled when the current db instance gets disposed.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_disposed">
            <summary>Set to true when the current db instance gets disposed.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.s_transactionCounter">
            <summary>Global counters used to generate the transaction's local id (for debugging purpose)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_transactions">
            <summary>List of all "pending" transactions created from this database instance (and that have not yet been disposed)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_globalSpace">
            <summary>Global namespace used to prefix ALL keys and subspaces accessible by this database instance (default is empty)</summary>
            <remarks>This is readonly and is set when creating the database instance</remarks>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_globalSpaceCopy">
            <summary>Copy of the namespace, that is exposed to the outside.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_defaultTimeout">
            <summary>Default Timeout value for all transactions</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_defaultRetryLimit">
            <summary>Default RetryLimit value for all transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.#ctor(FoundationDB.Client.FdbCluster,FoundationDB.Client.Native.DatabaseHandle,System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Boolean)">
            <summary>Create a new database instance</summary>
            <param name="cluster">Parent cluster</param>
            <param name="handle">Handle to the native FDB_DATABASE*</param>
            <param name="name">Name of the database</param>
            <param name="subspace">Root namespace of all keys accessible by this database instance</param>
            <param name="readOnly">If true, the database instance will only allow read-only transactions</param>
            <param name="ownsCluster">If true, the cluster instance lifetime is linked with the database instance</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.BeginTransaction(FoundationDB.Client.FdbTransactionMode,System.Threading.CancellationToken,FoundationDB.Client.FdbOperationContext)">
            <summary>Start a new transaction on this database</summary>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <returns>New transaction instance that can read from or write to the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginTransaction(CancellationToken.None))
            {
            	tr.Set(Slice.FromString("Hello"), Slice.FromString("World"));
            	tr.Clear(Slice.FromString("OldValue"));
            	await tr.CommitAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.CreateNewTransaction(FoundationDB.Client.FdbOperationContext)">
            <summary>Start a new transaction on this database, with an optional context</summary>
            <param name="context">Optional context in which the transaction will run</param>
            <param name="readOnly">If true, only read operations are allowed, and all write attempts will throw.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.RegisterTransaction(FoundationDB.Client.FdbTransaction)">
            <summary>Add a new transaction to the list of tracked transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.UnregisterTransaction(FoundationDB.Client.FdbTransaction)">
            <summary>Remove a transaction from the list of tracked transactions</summary>
            <param name="transaction"></param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadAsync(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-only transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-only transaction on each retry.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadAsync``1(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-only transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-only transaction on each retry. The result of the task will also be the result of the transactional.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.WriteAsync(System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a write-only transaction context, with retry logic.</summary>
            <param name="handler">Lambda function that is passed a new read-write transaction on each retry. It should only call non-async methods, such as Set, Clear or any atomic operation.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadWriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-write transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-write transaction on each retry.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadWriteAsync``1(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-write transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-write transaction on each retry. The result of the task will also be the result of the transactional.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption)">
            <summary>Set a parameter-less option on this database</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption,System.String)">
            <summary>Set an option on this database that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption,System.Int64)">
            <summary>Set an option on this database that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ChangeGlobalSpace(FoundationDB.Client.FdbSubspace)">
            <summary>Change the current global namespace.</summary>
            <remarks>Do NOT call this, unless you know exactly what you are doing !</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.IsKeyValid(FoundationDB.Client.Slice)">
            <summary>Test if a key is allowed to be used with this database instance</summary>
            <param name="key">Key to test</param>
            <returns>Returns true if the key is not null or empty, does not exceed the maximum key size, and is contained in the global key space of this database instance. Otherwise, returns false.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.EnsureKeyIsValid(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Checks that a key is inside the global namespace of this database, and contained in the optional legal key space specified by the user</summary>
            <param name="key">Key to verify</param>
            <param name="endExclusive">If true, the key is allowed to be one past the maximum key allowed by the global namespace</param>
            <exception cref="T:FoundationDB.Client.FdbException">If the key is outside of the allowed keyspace, throws an FdbException with code FdbError.KeyOutsideLegalRange</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FoundationDB.Client.FdbDatabase.ValidateKey(FoundationDB.Client.Slice,System.Boolean)" -->
        <member name="M:FoundationDB.Client.FdbDatabase.IsSystemKey(FoundationDB.Client.Slice)">
            <summary>Returns true if the key is inside the system key space (starts with '\xFF')</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FoundationDB.Client.FdbDatabase.EnsureValueIsValid(FoundationDB.Client.Slice)" -->
        <member name="P:FoundationDB.Client.FdbDatabase.Cluster">
            <summary>Cluster where the database is located</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Name">
            <summary>Name of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Handle">
            <summary>Handle to the underlying FDB_DATABASE*</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Token">
            <summary>Returns a cancellation token that is linked with the lifetime of this database instance</summary>
            <remarks>The token will be cancelled if the database instance is disposed</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.GlobalSpace">
            <summary>Returns the global namespace used by this database instance</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.DefaultTimeout">
            <summary>Default Timeout value (in milliseconds) for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.DefaultRetryLimit">
            <summary>Default Retry Limit value for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="T:FoundationDB.Client.FdbCluster">
            <summary>FoundationDB Cluster</summary>
            <remarks>Wraps an FDBCluster* handle</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.Dispose">
            <summary>Close the connection with the FoundationDB cluster</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.OpenDatabaseAsync(System.String,System.Threading.CancellationToken)">
            <summary>Opens a database on this cluster</summary>
            <param name="databaseName">Name of the database. Must be 'DB'</param>
            <param name="cancellationToken">Cancellation Token</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.InvalidOperationException">If <paramref name="databaseName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
            <remarks>As of Beta2, the only supported database name is 'DB'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.OpenDatabaseAsync(System.String,FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>Opens a database on this cluster, configured to only access a specific subspace of keys</summary>
            <param name="databaseName">Name of the database. Must be 'DB' (as of Beta 2)</param>
            <param name="subspace">Subspace of keys that will be accessed.</param>
            <param name="cancellationToken">Cancellation Token (optionnal) for the connect operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.InvalidOperationException">If <paramref name="databaseName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
            <remarks>Any attempt to use a key outside the specified subspace will throw an exception</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.OpenDatabaseAsync(System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>Opens a database on this cluster</summary>
            <param name="databaseName">Name of the database. Must be 'DB'</param>
            <param name="subspace">Subspace of keys that will be accessed.</param>
            <param name="ownsCluster">If true, the database will dispose this cluster when it is disposed.</param>
            <param name="cancellationToken">Cancellation Token</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.InvalidOperationException">If <paramref name="databaseName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
            <remarks>As of Beta2, the only supported database name is 'DB'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.SetOption(FoundationDB.Client.FdbClusterOption)">
            <summary>Set an option on this cluster that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.SetOption(FoundationDB.Client.FdbClusterOption,System.String)">
            <summary>Set an option on this cluster that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="P:FoundationDB.Client.FdbCluster.Path">
            <summary>Path to the cluster file used by this connection, or null if the default cluster file is being used</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFutureSingle`1">
            <summary>FDBFuture wrapper</summary>
            <typeparam name="T">Type of result</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureSingle`1.m_handle">
            <summary>Value of the 'FDBFuture*'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureSingle`1.m_resultSelector">
            <summary>Lambda used to extract the result of this FDBFuture</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureSingle`1.CallbackHandler">
            <summary>Cached delegate of the future completion callback handler</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureSingle`1.FutureCompletionCallback(System.IntPtr,System.IntPtr)">
            <summary>Handler called when a FDBFuture becomes ready</summary>
            <param name="futureHandle">Handle on the future that became ready</param>
            <param name="parameter">Paramter to the callback (unused)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureSingle`1.HandleCompletion(System.Boolean)">
            <summary>Update the Task with the state of a ready Future</summary>
            <param name="future">Future that should be ready</param>
            <returns>True if we got a result, or false in case of error (or invalid state)</returns>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncMode">
            <summary>
            Defines the intent of a consumer of an async iterator
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Default">
            <summary>
            Use the default settings. The provider will make no attempt at optimizing the query.
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Iterator">
            <summary>
            The query will be consumed by chunks and may be aborted at any point. The provider will produce small chunks of data for the first few reads but should still be efficient if the caller consume all the sequence.
            </summary>
            
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.All">
            <summary>
            The query will consume all the items in the source. The provider will produce large chunks of data immediately, and reduce the number of pages needed to consume the sequence.
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Head">
            <summary>
            The query will consume the first element (or a very small fraction) of the source. The provider will only produce data in small chunks and expect the caller to abort after one or two iterations. This can also be used to reduce the latency of the first result.
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Bulk">
            <summary>
            The query will consume all (or most of) the items of a very large sequence of data. The provider will use the appropriate page size in ordre to optimize the bandwith.
            </summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbTakeWhileAsyncIterator`1">
            <summary>Reads an async sequence of items until a condition becomes false</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncFilter`2.m_source">
            <summary>Source sequence (when in iterable mode)</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncFilter`2.m_iterator">
            <summary>Active iterator on the source (when in terator mode)</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbParallelQueryOptions">
            <summary>Container class for all settings relative to parallel operations</summary>
        </member>
        <member name="P:FoundationDB.Linq.FdbParallelQueryOptions.MaxConcurrency">
            <summary>Maximum number of concurrent async tasks that can run in parallel</summary>
        </member>
        <member name="P:FoundationDB.Linq.FdbParallelQueryOptions.Scheduler">
            <summary>Task Scheduler to use when executing async tasks</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncIteratorPump`1">
            <summary>Pump that repeatedly calls MoveNext on an iterator and tries to publish the values in a Producer/Consumer queue</summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncIteratorPump`1.PumpAsync(System.Threading.CancellationToken)">
            <summary>Run the pump until the inner iterator is done, an error occurs, or the cancellation token is fired</summary>
        </member>
        <member name="P:FoundationDB.Linq.FdbAsyncIteratorPump`1.IsCompleted">
            <summary>Returns true if the pump has completed (with success or failure)</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncCancelableMutex">
            <summary>Implements a async mutex that supports cancellation</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncCancelableMutex.CancellationHandler(System.Object)">
            <summary>Handler called if the CancellationToken linked to a waiter is signaled</summary>
            <param name="state"></param>
        </member>
        <member name="T:FoundationDB.Async.AsyncHelpers">
            <summary>
            Helper methods for creating and manipulating async sequences.
            </summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncHelpers.PumpToListAsync``1(FoundationDB.Async.IAsyncSource{``0},System.Threading.CancellationToken)">
            <summary>Pump the content of a source into a list</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncTransformQueue`2">
            <summary>Implements an async queue that asynchronously transform items, outputing them in arrival order, while throttling the producer</summary>
            <typeparam name="TInput">Type of the input elements (from the inner async iterator)</typeparam>
            <typeparam name="TOutput">Type of the output elements (produced by an async lambda)</typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncBuffer`2">
            <summary>Defines a producer/consumer buffer queue that can hold several items before blocking the producer</summary>
            <typeparam name="TInput">Type of elements entering the buffer</typeparam>
            <typeparam name="TOutput">Type of elements exiting the buffer. Can be different from <typeparamref name="TInput"/> if the buffer also transforms the elements.</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncBuffer`2.DrainAsync">
            <summary>Wait for all the consumers to drain the queue</summary>
            <returns>Task that completes when all consumers have drained the queue</returns>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.Count">
            <summary>Returns the current number of items in the buffer</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.Capacity">
            <summary>Returns the maximum capacity of the buffer</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.IsProducerBlocked">
            <summary>Returns true if the producer is blocked (queue is full)</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.IsConsumerBlocked">
            <summary>Returns true if the consumer is blocked (queue is empty)</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.Count">
            <summary>Returns the current number of items in the queue</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.Capacity">
            <summary>Returns the maximum capacity of the queue</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.IsConsumerBlocked">
            <summary>Returns true if the producer is blocked (queue is full)</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.IsProducerBlocked">
            <summary>Returns true if the consumer is blocked (queue is empty)</summary>
        </member>
        <member name="T:FoundationDB.Async.Maybe`1">
            <summary>Either has a value, nothing, or an exception</summary>
            <typeparam name="T">Type of the value</typeparam>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.HasValue">
            <summary>If true, there is a value. If false, either no value or an exception</summary>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.Value">
            <summary>If HasValue is true, holds the value. Else, contains default(T)</summary>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.m_errorContainer">
            <summary>If HasValue is false optinally holds an error that was captured</summary>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.EmptyTask">
            <summary>Cached completed Task that always return an empty value</summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe`1.GetValueOrDefault">
            <summary>Returns the stored value, of the default value for the type if it was empty</summary>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Async.Maybe`1.ThrowIfFailed">
            <summary>Rethrows any captured error, if there was one.</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.Empty">
            <summary>Returns an empty value</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.IsEmpty">
            <summary>If true, then there is no value and no error</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.HasFailed">
            <summary>If true then there was an error captured</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.Error">
            <summary>Return the captured Error, or null if there wasn't any</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.CapturedError">
            <summary>Return the captured error context, or null if there wasn't any</summary>
        </member>
        <member name="T:FoundationDB.Async.Maybe">
            <summary>
            Helper methods for creating <see cref="T:FoundationDB.Async.Maybe`1"/> instances
            </summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Return``1(``0)">
            <summary>Wraps a value into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Nothing``1">
            <summary>Returns an empty <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Error``1(System.Exception)">
            <summary>Capture an exception into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Error``1(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>Capture an exception into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(``0,System.Func{``0,``1})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(``0,System.Func{``0,FoundationDB.Async.Maybe{``1}})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(FoundationDB.Async.Maybe{``0},System.Func{``0,``1})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(FoundationDB.Async.Maybe{``0},System.Func{``0,FoundationDB.Async.Maybe{``1}})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.FromTask``1(System.Threading.Tasks.Task{``0})">
            <summary>Convert a completed <see cref="T:System.Threading.Tasks.Task`1"/> into an equivalent <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.FromTask``1(System.Threading.Tasks.Task{FoundationDB.Async.Maybe{``0}})">
            <summary>Convert a completed <see cref="T:System.Threading.Tasks.Task`1"/> into an equivalent <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Unwrap``1(System.Threading.Tasks.Task{FoundationDB.Async.Maybe{``0}})">
            <summary>Streamline a potentially failed Task&lt;Maybe&lt;T&gt;&gt; into a version that capture the error into the <see cref="T:FoundationDB.Async.Maybe`1"/> itself</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2">
            <summary>[EXPERIMENTAL] Iterates over an async sequence of items, kick off an async task in parallel, and returning the results in order</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.DefaultMaxConcurrency">
            <summary>Default max concurrency when doing batch queries</summary>
            <remarks>TODO: this is a placeholder value !</remarks>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.m_pump">
            <summary>Pump that reads values from the inner iterator</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.m_pumpTask">
            <summary>Inner pump task</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.m_processingQueue">
            <summary>Queue that holds items that are being processed</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Create``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{FoundationDB.Linq.IFdbAsyncEnumerator{``0},FoundationDB.Linq.IFdbAsyncEnumerator{``1}})">
            <summary>Create a new async sequence that will transform an inner async sequence</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
            <param name="source">Source async sequence that will be wrapped</param>
            <param name="factory">Factory method called when the outer sequence starts iterating. Must return an async enumerator</param>
            <returns>New async sequence</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Create``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerator{``0},FoundationDB.Linq.IFdbAsyncEnumerator{``1}})">
            <summary>Create a new async sequence that will transform an inner sequence</summary>
            <typeparam name="TSource">Type of elements of the inner sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
            <param name="source">Source sequence that will be wrapped</param>
            <param name="factory">Factory method called when the outer sequence starts iterating. Must return an async enumerator</param>
            <returns>New async sequence</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Run``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},FoundationDB.Linq.FdbAsyncMode,System.Action{``0},System.Threading.CancellationToken)">
            <summary>Immediately execute an action on each element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="mode">If different than default, can be used to optimise the way the source will produce the items</param>
            <param name="action">Action to perform on each element as it arrives</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Number of items that have been processed</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Run``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},FoundationDB.Linq.FdbAsyncMode,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Immediately execute an asunc action on each element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="action">Asynchronous action to perform on each element as it arrives</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Number of items that have been processed</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Run``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},FoundationDB.Linq.FdbAsyncMode,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Immediately execute an asunc action on each element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="action">Asynchronous action to perform on each element as it arrives</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Number of items that have been processed</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FoundationDB.Linq.FdbAsyncEnumerable.Head``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)" -->
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Empty``1">
            <summary>Returns an empty async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Singleton``1(``0)">
            <summary>Returns an async sequence that only holds one item</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToAsyncEnumerable``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Apply an async lambda to a sequence of elements to transform it into an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToAsyncEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Apply an async lambda to a sequence of elements to transform it into an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.FromTask``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>Wraps an async lambda into an async sequence that will return the result of the lambda</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Projects each element of an async sequence to an IFdbAsyncEnumerable&lt;T&gt; and flattens the resulting sequences into one async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>Projects each element of an async sequence to an IFdbAsyncEnumerable&lt;T&gt; and flattens the resulting sequences into one async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>Projects each element of an async sequence to an IFdbAsyncEnumerable&lt;T&gt; and flattens the resulting sequences into one async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>Projects each element of an async sequence to an IFdbAsyncEnumerable&lt;T&gt; flattens the resulting sequences into one async sequence, and invokes a result selector function on each element therein.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,``2})">
            <summary>Projects each element of an async sequence to an IFdbAsyncEnumerable&lt;T&gt; flattens the resulting sequences into one async sequence, and invokes a result selector function on each element therein.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,``2})">
            <summary>Projects each element of an async sequence to an IFdbAsyncEnumerable&lt;T&gt; flattens the resulting sequences into one async sequence, and invokes a result selector function on each element therein.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Select``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,``1})">
            <summary>Projects each element of a async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Select``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Projects each element of a async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Select``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>Projects each element of a async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Where``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Filters an async sequence of values based on a predicate.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Where``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>Filters an async sequence of values based on a predicate.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Where``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>Filters an async sequence of values based on a predicate.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ForEachAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Action{``0},System.Threading.CancellationToken)">
            <summary>Execute an action for each element of an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ForEachAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Execute an async action for each element of an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ForEachAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Execute an async action for each element of an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToListAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Return a list of all the elements from an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToArrayAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Return an array with all the elements from an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToArrayAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Int32,System.Threading.CancellationToken)">
            <summary>Return a list of all the elements from an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.FirstAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first element of an async sequence, or an exception if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.FirstOrDefaultAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first element of an async sequence, or the default value for the type if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SingleAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first and only element of an async sequence, or an exception if it is empty or have two or more elements</summary>
            <remarks>Will need to call MoveNext at least twice to ensure that there is no second element.</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SingleOrDefaultAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first and only element of an async sequence, the default value for the type if it is empty, or an exception if it has two or more elements</summary>
            <remarks>Will need to call MoveNext at least twice to ensure that there is no second element.</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.LastAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the last element of an async sequence, or an exception if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.LastOrDefaultAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the last element of an async sequence, or the default value for the type if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.CountAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the number of elements in an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.CountAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean},System.Threading.CancellationToken)">
            <summary>Returns a number that represents how many elements in the specified async sequence satisfy a condition.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AnyAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Determines whether an async sequence contains any elements.</summary>
            <remarks>This is the logical equivalent to "source.Count() > 0" but can be better optimized by some providers</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AnyAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean},System.Threading.CancellationToken)">
            <summary>Determines whether any element of an async sequence satisfies a condition.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.NoneAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Determines wether an async sequence contains no elements at all.</summary>
            <remarks>This is the logical equivalent to "source.Count() == 0" or "!source.Any()" but can be better optimized by some providers</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.NoneAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean},System.Threading.CancellationToken)">
            <summary>Determines whether none of the elements of an async sequence satisfies a condition.</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.EnumerableIterator`2">
            <summary>Iterates over a sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.EnumerableSequence`2">
            <summary>Wraps a sequence of items into an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.EmptySequence`1">
            <summary>An empty sequence</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1">
            <summary>Small buffer that keeps a list of chunks that are larger and larger</summary>
            <typeparam name="T">Type of elements stored in the buffer</typeparam>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.DefaultCapacity">
            <summary>Default intial capacity, if not specified</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.MaxChunkSize">
            <summary>Maximum size of a chunk</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Count">
            <summary>Number of items in the buffer</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Index">
            <summary>Index in the current chunk</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Chunks">
            <summary>List of chunks</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Current">
            <summary>Current (and last) chunk</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbSelectManyAsyncIterator`2">
            <summary>Iterates over an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.SelectManyAsyncIterator`3">
            <summary>Iterates over an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbWhereAsyncIterator`1">
            <summary>Filters an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbWhereSelectAsyncIterator`2">
            <summary>Iterates over an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncSequence`2">
            <summary>Wraps an async sequence of items into another async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleParser">
            <summary>Helper class that contains low-level encoders for the tuple binary format</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteNil(FoundationDB.Client.Utils.SliceWriter@)">
            <summary>Writes a null value at the end, and advance the cursor</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteInt8(FoundationDB.Client.Utils.SliceWriter@,System.Byte)">
            <summary>Writes an UInt8 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Unsigned BYTE, 32 bits</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteInt32(FoundationDB.Client.Utils.SliceWriter@,System.Int32)">
            <summary>Writes an Int32 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed DWORD, 32 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteInt64(FoundationDB.Client.Utils.SliceWriter@,System.Int64)">
            <summary>Writes an Int64 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed QWORD, 64 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteUInt32(FoundationDB.Client.Utils.SliceWriter@,System.UInt32)">
            <summary>Writes an UInt32 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed DWORD, 32 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteUInt64(FoundationDB.Client.Utils.SliceWriter@,System.UInt64)">
            <summary>Writes an UInt64 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed QWORD, 64 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteBytes(FoundationDB.Client.Utils.SliceWriter@,System.Byte[])">
            <summary>Writes a binary string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteString(FoundationDB.Client.Utils.SliceWriter@,System.String)">
            <summary>Writes a string encoded in UTF-8</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteChars(FoundationDB.Client.Utils.SliceWriter@,System.Char[],System.Int32,System.Int32)">
            <summary>Writes a char array encoded in UTF-8</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteChar(FoundationDB.Client.Utils.SliceWriter@,System.Char)">
            <summary>Writes a char encoded in UTF-8</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteBytes(FoundationDB.Client.Utils.SliceWriter@,System.Byte[],System.Int32,System.Int32)">
            <summary>Writes a binary string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteBytes(FoundationDB.Client.Utils.SliceWriter@,System.ArraySegment{System.Byte})">
            <summary>Writes a binary string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteNulEscapedBytes(FoundationDB.Client.Utils.SliceWriter@,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <summary>Writes a buffer with all instances of 0 escaped as '00 FF'</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteNulEscapedBytes(FoundationDB.Client.Utils.SliceWriter@,System.Byte,System.Byte[])">
            <summary>Writes a buffer with all instances of 0 escaped as '00 FF'</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteGuid(FoundationDB.Client.Utils.SliceWriter@,System.Guid)">
            <summary>Writes a RFC 4122 encoded 16-byte Microsoft GUID</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteUuid(FoundationDB.Client.Utils.SliceWriter@,FoundationDB.Client.Uuid)">
            <summary>Writes a RFC 4122 encoded 128-bit UUID</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleParser.MultiplyDeBruijnBitPosition">
            <summary>Lookup table used to compute the index of the most significant bit</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.NumberOfBytes(System.UInt32)">
            <summary>Returns the minimum number of bytes needed to represent a value</summary>
            <remarks>Note: will return 1 even for <param name="v"/> == 0</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.NumberOfBytes(System.Int64)">
            <summary>Returns the minimum number of bytes needed to represent a value</summary>
            <remarks>Note: will return 1 even for <param name="v"/> == 0</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.NumberOfBytes(System.UInt64)">
            <summary>Returns the minimum number of bytes needed to represent a value</summary>
            <returns>Note: will return 1 even for <param name="v"/> == 0</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.MostSignificantBit(System.UInt32)">
            <summary>Returns the position of the most significant bit (0-based) in a 32-bit integer</summary>
            <param name="v">32-bit integer</param>
            <returns>Index of the most significant bit (0-based)</returns>
        </member>
        <member name="T:FoundationDB.Client.Native.DebugCounters">
            <summary>Simple debug counters container that is used to troubleshoot alloc/free problems...</summary>
        </member>
        <member name="M:FoundationDB.Client.Serializers.FdbValueEncoder.Create``1(System.Func{``0,FoundationDB.Client.Slice},System.Func{FoundationDB.Client.Slice,``0})">
            <summary>Create a new serializer from a two packing and unpacking lambdas</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:FoundationDB.Client.Serializers.FdbValueEncoder.Encode``1(``0,FoundationDB.Client.IFdbValueEncoder{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:FoundationDB.Client.Serializers.FdbValueEncoder.Encode``1(``0[],FoundationDB.Client.IFdbValueEncoder{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:FoundationDB.Client.Serializers.FdbValueEncoder.Encode``1(System.Collections.Generic.IEnumerable{``0},FoundationDB.Client.IFdbValueEncoder{``0})" -->
        <member name="M:FoundationDB.Client.Serializers.FdbValueEncoder.Decode``1(FoundationDB.Client.Slice,FoundationDB.Client.IFdbValueEncoder{``0})">
            <summary>Convert a slice back into a <typeparamref name="T"/>, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.Serializers.FdbValueEncoder.Decode``1(FoundationDB.Client.Slice[],FoundationDB.Client.IFdbValueEncoder{``0})">
            <summary>Convert an array of slices back into an array of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.Serializers.FdbValueEncoder.Decode``1(System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice},FoundationDB.Client.IFdbValueEncoder{``0})">
            <summary>Transform a sequence of slices back into a sequence of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="T:FoundationDB.Client.Serializers.FdbValueEncoder.SerializableSerializer`1">
            <summary>Simple serializer that can pack or unpack types that implement ISliceSerializable</summary>
        </member>
        <member name="T:FoundationDB.Client.Serializers.FdbValueEncoder`1">
            <summary>Very simple serializer that uses FdbConverters to convert values of type <typeparamref name="T"/> from/to Slice</summary>
            <typeparam name="T">Type of the value to serialize/deserialize</typeparam>
        </member>
        <member name="M:FoundationDB.Client.Serializers.FdbValueEncoder`1.Decode(FoundationDB.Client.Slice)">
            <summary>Deserialize a packed representation into a <typeparamref name="T"/> instance</summary>
            <param name="slice">Packed representation</param>
            <returns>Deserialized <typeparamref name="T"/> instance.</returns>
        </member>
        <member name="M:FoundationDB.Client.Serializers.FdbValueEncoder`1.Encode(`0)">
            <summary>Serialize a <typeparamref name="T"/> instance into a packed representation</summary>
            <param name="value">Value to serialize</param>
            <returns>Packed representation of <paramref name="value"/></returns>
        </member>
        <member name="P:FoundationDB.Client.Serializers.FdbValueEncoder`1.Default">
            <summary>Default slice serializer for values of type <typeparam name="T"/></summary>
        </member>
        <member name="T:FoundationDB.Client.ISliceSerializable">
            <summary>Allows an object to control the way it is packed or unpacked</summary>
        </member>
        <member name="M:FoundationDB.Client.ISliceSerializable.ToSlice">
            <summary>Return the packed representation of this instance</summary>
        </member>
        <member name="M:FoundationDB.Client.ISliceSerializable.FromSlice(FoundationDB.Client.Slice)">
            <summary>Load a packed representation into a newly created instance</summary>
        </member>
        <member name="T:FoundationDB.Client.Uuid">
            <summary>RFC 4122 compliant 128-bit UUID</summary>
            <remarks>You should use this type if you are primarily exchanged UUIDs with non-.NET platforms, that use the RFC 4122 byte ordering (big endian). The type System.Guid uses the Microsoft encoding (little endian) and is not compatible.</remarks>
        </member>
        <member name="T:FoundationDB.Client.SliceListStream">
            <summary>Merge multiple slices into a single stream</summary>
        </member>
        <member name="T:FoundationDB.Client.SliceStream">
            <summary>Stream that wraps a Slice for reading</summary>
            <remarks>This stream is optimized for blocking and async reads</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.Logging.SetLevel(System.Diagnostics.SourceLevels)">
            <summary>Set/Update the trave level</summary>
            <param name="level"></param>
        </member>
        <member name="P:FoundationDB.Client.Utils.Logging.On">
            <summary>Return true if logging is enabled; otherwise false</summary>
        </member>
        <member name="P:FoundationDB.Client.Utils.Logging.Source">
            <summary>Return the TraceSource used for logging</summary>
        </member>
        <member name="T:FoundationDB.Client.Slice">
            <summary>Delimits a section of a byte array</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Nil">
            <summary>Null slice ("no segment")</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Empty">
            <summary>Empty slice ("segment of 0 bytes")</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Array">
            <summary>Pointer to the buffer (or null for Slice.Nil)</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Offset">
            <summary>Offset of the first byte of the slice in the parent buffer</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Count">
            <summary>Number of bytes in the slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Byte[])">
            <summary>Creates a slice mapping an entire buffer</summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.ArraySegment{System.Byte})">
            <summary>Creates a slice from an Array Segment</summary>
            <param name="arraySegment">Segment of buffer to convert</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a slice mapping a section of a buffer</summary>
            <param name="buffer">Original buffer</param>
            <param name="offset">Offset into buffer</param>
            <param name="count">Number of bytes</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Int32)">
            <summary>Create a new empty slice of a specified size containing all zeroes</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Byte*,System.Int32)">
            <summary>Creates a new slice with a copy of an unmanaged memory buffer</summary>
            <param name="ptr">Pointer to unmanaged buffer</param>
            <param name="count">Number of bytes in the buffer</param>
            <returns>Slice with a managed copy of the data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Random(System.Random,System.Int32)">
            <summary>Create a new slice filled with random bytes taken from a random number generator</summary>
            <param name="prng">Pseudo random generator to use (needs locking if instance is shared)</param>
            <param name="count">Number of random bytes to generate</param>
            <returns>Slice of <paramref name="count"/> bytes taken from <paramref name="prng"/></returns>
            <remarks>Warning: <see cref="T:System.Random"/> is not thread-safe ! If the <paramref name="prng"/> instance is shared between threads, then it needs to be locked before calling this method.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Random(System.Security.Cryptography.RandomNumberGenerator,System.Int32,System.Boolean)">
            <summary>Create a new slice filled with random bytes taken from a cryptographic random number generator</summary>
            <param name="rng">Random generator to use (needs locking if instance is shared)</param>
            <param name="count">Number of random bytes to generate</param>
            <returns>Slice of <paramref name="count"/> bytes taken from <paramref name="rng"/></returns>
            <remarks>Warning: All RNG implementations may not be thread-safe ! If the <paramref name="rng"/> instance is shared between threads, then it may need to be locked before calling this method.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromBase64(System.String)">
            <summary>Decode a Base64 encoded string into a slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromByte(System.Byte)">
            <summary>Encode an unsigned 8-bit integer into a slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromInt32(System.Int32)">
            <summary>Encode a signed 32-bit integer into a variable size slice (1, 2 or 4 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixed32(System.Int32)">
            <summary>Encode a signed 32-bit integer into a 4-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUInt32(System.UInt32)">
            <summary>Encode an unsigned 32-bit integer into a variable size slice (1, 2 or 4 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU32(System.UInt32)">
            <summary>Encode an unsigned 32-bit integer into a 4-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromInt64(System.Int64)">
            <summary>Encode a signed 64-bit integer into a variable size slice (1, 2, 4 or 8 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixed64(System.Int64)">
            <summary>Encode a signed 64-bit integer into a 8-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUInt64(System.UInt64)">
            <summary>Encode an unsigned 64-bit integer into a variable size slice (1, 2, 4 or 8 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU64(System.UInt64)">
            <summary>Encode an unsigned 64-bit integer into a 8-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromGuid(System.Guid)">
            <summary>Create a 16-byte slice containing a System.Guid encoding according to RFC 4122 (Big Endian)</summary>
            <remarks>WARNING: Slice.FromGuid(guid).GetBytes() will not produce the same result as guid.ToByteArray() !
            If you need to produce Microsoft compatible byte arrays, use Slice.Create(guid.ToByteArray()) but then you shoud NEVER use Slice.ToGuid() to decode such a value !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUuid(FoundationDB.Client.Uuid)">
            <summary>Create a 16-byte slice containing an RFC 4122 compliant 128-bit UUID</summary>
            <remarks>You should never call this method on a slice created from the result of calling System.Guid.ToByteArray() !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromAscii(System.String)">
            <summary>Dangerously create a slice containing string converted to ASCII. All non-ASCII characters may be corrupted or converted to '?'</summary>
            <remarks>WARNING: if you put a string that contains non-ASCII chars, it will be silently corrupted! This should only be used to store keywords or 'safe' strings.
            Note: depending on your default codepage, chars from 128 to 255 may be preserved, but only if they are decoded using the same codepage at the other end !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromString(System.String)">
            <summary>Create a slice containing the UTF-8 bytes of the string <paramref name="value"/></summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromChar(System.Char)">
            <summary>Create a slice that holds the UTF-8 encoded representation of <paramref name="value"/></summary>
            <param name="value"></param>
            <returns>The returned slice is only guaranteed to hold 1 byte for ASCII chars (0..127). For non-ASCII chars, the size can be from 1 to 6 bytes.
            If you need to use ASCII chars, you should use Slice.FromByte() instead</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.NibbleToDecimal(System.Char)">
            <summary>Convert an hexadecimal digit (0-9A-Fa-f) into the corresponding decimal value</summary>
            <param name="c">Hexadecimal digit (case insensitive)</param>
            <returns>Decimal value between 0 and 15, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromHexa(System.String)">
            <summary>Convert an hexadecimal encoded string ("1234AA7F") into a slice</summary>
            <param name="hexaString">String contains a sequence of pairs of hexadecimal digits with no separating spaces.</param>
            <returns>Slice containing the decoded byte array, or an exeception if the string is empty or has an odd length</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.GetBytes">
            <summary>Return a byte array containing all the bytes of the slice, or null if the slice is null</summary>
            <returns>Byte array with a copy of the slice, or null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.GetBytes(System.Int32,System.Int32)">
            <summary>Return a byte array containing a subset of the bytes of the slice, or null if the slice is null</summary>
            <returns>Byte array with a copy of a subset of the slice, or null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.AsStream">
            <summary>Return a stream that wraps this slice</summary>
            <returns>Stream that will read the slice from the start.</returns>
            <remarks>
            You can use this method to convert text into specific encodings, load bitmaps (JPEG, PNG, ...), or any serialization format that requires a Stream or TextReader instance.
            Disposing this stream will have no effect on the slice.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToAscii">
            <summary>Stringify a slice containing only ASCII chars</summary>
            <returns>ASCII string, or null if the slice is null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToUnicode">
            <summary>Stringify a slice containing an UTF-8 encoded string</summary>
            <returns>Unicode string, or null if the slice is null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToBase64">
            <summary>Converts a slice using Base64 encoding</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToHexaString">
            <summary>Converts a slice into a string with each byte encoded into hexadecimal (lowercase)</summary>
            <returns>"0123456789abcdef"</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToHexaString(System.Char)">
            <summary>Converts a slice into a string with each byte encoded into hexadecimal (uppercase) separated by a char</summary>
            <param name="sep">Character used to separate the hexadecimal pairs (ex: ' ')</param>
            <returns>"01 23 45 67 89 ab cd ef"</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToAsciiOrHexaString">
            <summary>Helper method that dumps the slice as a string (if it contains only printable ascii chars) or an hex array if it contains non printable chars. It should only be used for logging and troubleshooting !</summary>
            <returns>Returns either "'abc'" or "&lt;00 42 7F&gt;". Returns "''" for Slice.Empty, and "" for Slice.Nil</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Memoize">
            <summary>Returns a new slice that contains an isolated copy of the buffer</summary>
            <returns>Slice that is equivalent, but is isolated from any changes to the buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.UnsafeMapToOffset(System.Int32)">
            <summary>Map an offset in the slice into the absolute offset in the buffer, without any bound checking</summary>
            <param name="index">Relative offset (negative values mean from the end)</param>
            <returns>Absolute offset in the buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.MapToOffset(System.Int32)">
            <summary>Map an offset in the slice into the absolute offset in the buffer</summary>
            <param name="index">Relative offset (negative values mean from the end)</param>
            <returns>Absolute offset in the buffer</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the index is outside the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.NormalizeIndex(System.Int32)">
            <summary>Normalize negative index values into offset from the start</summary>
            <param name="index">Relative offset (negative values mean from the end)</param>
            <returns>Relative offset from the start of the slice</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Append(System.Byte[],System.Int32@)">
            <summary>Copy this slice into another buffer</summary>
            <param name="buffer">Buffer where to copy this slice</param>
            <param name="cursor">Offset into the destination buffer</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.CopyTo(System.Byte[],System.Int32)">
            <summary>Copy this slice into another buffer</summary>
            <param name="buffer">Buffer where to copy this slice</param>
            <param name="offset">Offset into the destination buffer</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.Substring(System.Int32)">
            <summary>Retrieves a substring from this instance. The substring starts at a specified character position.</summary>
            <param name="offset">The starting position of the substring. Positive values mmeans from the start, negative values means from the end</param>
            <returns>A slice that is equivalent to the substring that begins at <paramref name="offset"/> (from the start or the end depending on the sign) in this instance, or Slice.Empty if <paramref name="offset"/> is equal to the length of the slice.</returns>
            <remarks>The substring does not copy the original data, and refers to the same buffer as the original slice. Any change to the parent slice's buffer will be seen by the substring. You must call Memoize() on the resulting substring if you want a copy</remarks>
            <example>{"ABCDE"}.Substring(0) =&gt; {"ABC"}
            {"ABCDE"}.Substring(1} =&gt; {"BCDE"}
            {"ABCDE"}.Substring(-2} =&gt; {"DE"}
            {"ABCDE"}.Substring(5} =&gt; Slice.Empty
            Slice.Empty.Substring(0) =&gt; Slice.Empty
            Slice.Nil.Substring(0) =&gt; Slice.Emtpy
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> indicates a position not within this instance, or <paramref name="offset"/> is less than zero</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.Substring(System.Int32,System.Int32)">
            <summary>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.</summary>
            <param name="offset">The starting position of the substring. Positive values means from the start, negative values means from the end</param>
            <param name="count">Number of bytes in the substring</param>
            <returns>A slice that is equivalent to the substring of length <paramref name="count"/> that begins at <paramref name="offset"/> (from the start or the end depending on the sign) in this instance, or Slice.Empty if count is zero.</returns>
            <remarks>The substring does not copy the original data, and refers to the same buffer as the original slice. Any change to the parent slice's buffer will be seen by the substring. You must call Memoize() on the resulting substring if you want a copy</remarks>
            <example>{"ABCDE"}.Substring(0, 3) =&gt; {"ABC"}
            {"ABCDE"}.Substring(1, 3} =&gt; {"BCD"}
            {"ABCDE"}.Substring(-2, 2} =&gt; {"DE"}
            Slice.Empty.Substring(0, 0) =&gt; Slice.Empty
            Slice.Nil.Substring(0, 0) =&gt; Slice.Emtpy
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> plus <paramref name="count"/> indicates a position not within this instance, or <paramref name="offset"/> or <paramref name="count"/> is less than zero</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.StartsWith(FoundationDB.Client.Slice)">
            <summary>Determines whether the beginning of this slice instance matches a specified slice.</summary>
            <param name="value">The slice to compare</param>
            <returns><b>true</b> if <paramref name="value"/> matches the beginning of this slice; otherwise, <b>false</b></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.EndsWith(FoundationDB.Client.Slice)">
            <summary>Determines whether the end of this slice instance matches a specified slice.</summary>
            <param name="value">The slice to compare to the substring at the end of this instance.</param>
            <returns><b>true</b> if <paramref name="value"/> matches the end of this slice; otherwise, <b>false</b></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.PrefixedBy(FoundationDB.Client.Slice)">
            <summary>Equivalent of StartsWith, but the returns false if both slices are identical</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.SuffixedBy(FoundationDB.Client.Slice)">
            <summary>Equivalent of EndsWith, but the returns false if both slices are identical</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.Concat(FoundationDB.Client.Slice)">
            <summary>Append/Merge a slice at the end of the current slice</summary>
            <param name="tail">Slice that must be appended</param>
            <returns>Merged slice if both slices are contigous, or a new slice containg the content of the current slice, followed by the tail slice</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Implicit(FoundationDB.Client.Slice)~System.ArraySegment{System.Byte}">
            <summary>Implicitly converts a Slice into an ArraySegment&lt;byte&gt;</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Implicit(System.ArraySegment{System.Byte})~FoundationDB.Client.Slice">
            <summary>Implicitly converts an ArraySegment&lt;byte&gt; into a Slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Equality(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices for equality</summary>
            <returns>True if the slice contains the same bytes</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Inequality(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices for inequality</summary>
            <returns>True if the slice do not contain the same bytes</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Addition(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Append/Merge two slices together</summary>
            <param name="a">First slice</param>
            <param name="b">Second slice</param>
            <returns>Merged slices if both slices are contigous, or a new slice containg the content of the first slice, followed by the second</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Addition(FoundationDB.Client.Slice,System.Byte)">
            <summary>Appends a byte at the end of the slice</summary>
            <param name="a">First slice</param>
            <param name="b">Byte to append at the end</param>
            <returns>New slice with the byte appended</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Subtraction(FoundationDB.Client.Slice,System.Int32)">
            <summary>Remove <paramref name="n"/> bytes at the end of slice <paramref name="s"/></summary>
            <returns>Smaller slice</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToString">
            <summary>Returns a printable representation of the key</summary>
            <remarks>You can roundtrip the result of calling slice.ToString() by passing it to <see cref="M:FoundationDB.Client.Slice.Unescape(System.String)"/>(string) and get back the original slice.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Dump(FoundationDB.Client.Slice)">
            <summary>Returns a printable representation of a key</summary>
            <remarks>This may not be efficient, so it should only be use for testing/logging/troubleshooting</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Unescape(System.String)">
            <summary>Decode the string that was generated by slice.ToString() or Slice.Dump(), back into the original slice</summary>
            <remarks>This may not be efficient, so it should only be use for testing/logging/troubleshooting</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromStream(System.IO.Stream)">
            <summary>Read the content of a stream into a slice</summary>
            <param name="data">Source stream, that must be in a readable state</param>
            <returns>Slice containing the stream content (or Slice.Nil if the stream is Stream.Nul)</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromStreamAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>Asynchronously read the content of a stream into a slice</summary>
            <param name="data">Source stream, that must be in a readable state</param>
            <returns>Slice containing the stream content (or Slice.Nil if the stream is Stream.Nul)</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.LoadFromNonBlockingStream(System.IO.Stream,System.Int32)">
            <summary>Read from a non-blocking stream that already contains all the data in memory (MemoryStream, UnmanagedStream, ...)</summary>
            <param name="source">Source stream</param>
            <param name="length">Number of bytes to read from the stream</param>
            <returns>Slice containing the loaded data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.LoadFromBlockingStream(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Synchronously read from a blocking stream (FileStream, NetworkStream, ...)</summary>
            <param name="source">Source stream</param>
            <param name="length">Number of bytes to read from the stream</param>
            <param name="chunkSize">If non zero, max amount of bytes to read in one chunk. If zero, tries to read everything at once</param>
            <returns>Slice containing the loaded data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.LoadFromBlockingStreamAsync(System.IO.Stream,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>Asynchronously read from a blocking stream (FileStream, NetworkStream, ...)</summary>
            <param name="source">Source stream</param>
            <param name="length">Number of bytes to read from the stream</param>
            <param name="chunkSize">If non zero, max amount of bytes to read in one chunk. If zero, tries to read everything at once</param>
            <returns>Slice containing the loaded data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.CompareTo(FoundationDB.Client.Slice)">
            <summary>Lexicographically compare this slice with another one</summary>
            <param name="other">Other slice to compare</param>
            <returns>0 for equal, positive if we are greater, negative if we are smaller</returns>
            <remarks>Nil/Empty is equal to itself, and smaller than everything else</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.SameBytes(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two byte segments for equalit</summary>
            <param name="left">Left buffer</param>
            <param name="leftOffset">Start offset in left buffer</param>
            <param name="right">Right buffer</param>
            <param name="rightOffset">Start offset in right buffer</param>
            <param name="count">Number of bytes to compare</param>
            <returns>true if all bytes are the same in both segments</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.CompareBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two byte segments lexicographically</summary>
            <param name="left">Left buffer</param>
            <param name="leftOffset">Start offset in left buffer</param>
            <param name="leftCount">Number of bytes in left buffer</param>
            <param name="right">Right buffer</param>
            <param name="rightOffset">Start offset in right buffer</param>
            <param name="rightCount">Number of bytes in right buffer</param>
            <returns>Returns zero if segments are identical (same bytes), a negative value if left is lexicographically less than right, or a positive value if left is lexicographically greater than right</returns>
            <remarks>The comparison algorithm respect the following:
            * "A" &lt; "B"
            * "A" &lt; "AA"
            * "AA" &lt; "B"</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.HasValue">
            <summary>Returns true is the slice is not null</summary>
            <remarks>An empty slice is NOT considered null</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsNull">
            <summary>Returns true if the slice is null</summary>
            <remarks>An empty slice is NOT considered null</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsEmpty">
            <summary>Return true if the slice is not null but contains 0 bytes</summary>
            <remarks>A null slice is NOT empty</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsNullOrEmpty">
            <summary>Returns true if the slice is null or empty, or false if it contains at least one byte</summary>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsPresent">
            <summary>Returns true if the slice contains at least one byte, or false if it is null or empty</summary>
        </member>
        <member name="P:FoundationDB.Client.Slice.Item(System.Int32)">
            <summary>Returns the value of one byte in the slice</summary>
            <param name="index">Offset of the byte (negative values means start from the end)</param>
        </member>
        <member name="P:FoundationDB.Client.Slice.Item(System.Int32,System.Int32)">
            <summary>Returns a substring of the current slice that fits withing the specified index range</summary>
            <param name="start">The starting position of the substring. Positive values means from the start, negative values means from the end</param>
            <param name="end">The end position (exlucded) of the substring. Positive values means from the start, negative values means from the end</param>
            <returns>Subslice</returns>
        </member>
        <member name="T:FoundationDB.Client.SliceReader">
            <summary>Helper class that holds the internal state used to parse tuples from slices</summary>
        </member>
        <member name="F:FoundationDB.Client.SliceReader.Buffer">
            <summary>Buffer containing the tuple being parsed</summary>
        </member>
        <member name="F:FoundationDB.Client.SliceReader.Position">
            <summary>Current position inside the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.EnsureBytes(System.Int32)">
            <summary>Ensure that there are at least <paramref name="count"/> bytes remaining in the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.PeekByte">
            <summary>Return the value of the next byte in the buffer, or -1 if we reached the end</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.Skip(System.Int32)">
            <summary>Skip the next <paramref name="count"/> bytes of the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadByte">
            <summary>Read the next byte from the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadBytes(System.Int32)">
            <summary>Read the next <paramref name="count"/> bytes from the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadByteString">
            <summary>Read an encoded nul-terminated byte array from the buffer</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceReader.HasMore">
            <summary>Returns true if there are more bytes to parse</summary>
        </member>
        <member name="T:FoundationDB.Client.Utils.SliceWriter">
            <summary>Slice buffer that emulates a pseudo-stream using a byte array that will automatically grow in size, if necessary</summary>
            <remarks>IMPORTANT: This struct does not extensively check the parameters! The caller should ensure that everything is valid (this is to get the max performance when serializing keys and values)</remarks>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceWriter.Buffer">
            <summary>Buffer holding the data</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceWriter.Position">
            <summary>Position in the buffer ( == number of already written bytes)</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.#ctor(System.Int32)">
            <summary>Create a new empty binary buffer with an initial allocated size</summary>
            <param name="capacity"></param>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.#ctor(System.Byte[])">
            <summary>Create a new binary writer using an existing buffer</summary>
            <param name="buffer"></param>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.#ctor(System.Byte[],System.Int32)">
            <summary>Create a new binary writer using an existing buffer and with the cursor to a specific location</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.GetBytes">
            <summary>Returns a byte array filled with the contents of the buffer</summary>
            <remarks>The buffer is copied in the byte array. And change to one will not impact the other</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.ToSlice">
            <summary>Returns a slice pointing to the content of the buffer</summary>
            <remarks>Any change to the slice will change the buffer !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.ToSlice(System.Int32)">
            <summary>Returns a slice pointing to the first <paramref name="count"/> bytes of the buffer</summary>
            <param name="count">Size of the segment</param>
            <remarks>Any change to the slice will change the buffer !</remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="count"/> is less than zero, or larger than the current buffer size</exception>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.ToSlice(System.Int32,System.Int32)">
            <summary>Returns a slice pointing to a segment inside the buffer</summary>
            <param name="offset">Offset of the segment from the start of the buffer</param>
            <param name="count">Size of the segment</param>
            <remarks>Any change to the slice will change the buffer !</remarks>
            <exception cref="T:System.ArgumentException">If either <paramref name="offset"/> or <paramref name="count"/> are less then zero, or do not fit inside the current buffer</exception>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.SetLength(System.Int32)">
            <summary>Truncate the buffer by setting the cursor to the specified position.</summary>
            <param name="position">New size of the buffer</param>
            <remarks>If the buffer was smaller, it will be resized and filled with zeroes. If it was biffer, the cursor will be set to the specified position, but previous data will not be deleted.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.Flush(System.Int32)">
            <summary>Delete the first N bytes of the buffer, and shift the remaining to the front</summary>
            <param name="bytes">Number of bytes to remove at the head of the buffer</param>
            <returns>New size of the buffer (or 0 if it is empty)</returns>
            <remarks>This should be called after every successfull write to the underlying stream, to update the buffer.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.Reset">
            <summary>Empties the current buffer after a succesfull write</summary>
            <remarks>Shrink the buffer if a lot of memory is wated</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.Skip(System.Int32)">
            <summary>Advance the cursor of the buffer without writing anything</summary>
            <param name="skip">Number of bytes to skip</param>
            <returns>Position of the cursor BEFORE moving it. Can be used as a marker to go back later and fill some value</returns>
            <remarks>Will fill the skipped bytes with 0xFF</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.WriteByte(System.Byte)">
            <summary>Add a byte to the end of the buffer, and advance the cursor</summary>
            <param name="value">Byte, 8 bits</param>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.WriteBytes(System.Byte[])">
            <summary>Append a byte array to the end of the buffer</summary>
            <param name="data"></param>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Append a chunk of a byte array to the end of the buffer</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.WriteBytes(FoundationDB.Client.Slice)">
            <summary>Append a segment of bytes to the end of the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.WriteVarint32(System.UInt32)">
            <summary>Writes a 7-bit encoded unsigned int (aka 'Varint32') at the end, and advances the cursor</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.WriteVarint64(System.UInt64)">
            <summary>Writes a 7-bit encoded unsigned long (aka 'Varint64') at the end, and advances the cursor</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.EnsureBytes(System.Int32)">
            <summary>Ensures that we can fit a specific amount of data at the end of the buffer</summary>
            <param name="count">Number of bytes that will be written</param>
            <remarks>If the buffer is too small, it will be resized</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.EnsureOffsetAndSize(System.Int32,System.Int32)">
            <summary>Ensures that we can fit data at a specifc offset in the buffer</summary>
            <param name="offset">Offset into the buffer (from the start)</param>
            <param name="count">Number of bytes that will be written at this offset</param>
            <remarks>If the buffer is too small, it will be resized</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.GrowBuffer(System.Byte[]@,System.Int32)">
            <summary>Resize a buffer by doubling its capacity</summary>
            <param name="buffer">Reference to the variable holding the buffer to create/resize</param>
            <param name="minimumCapacity">Capacité minimum du buffer (si vide initialement) ou 0 pour "autogrowth"</param>
            <remarks>The buffer will be resized to the maximum betweeb the previous size multiplied by 2, and <paramref name="minimumCapacity"/>. The capacity will always be rounded to a multiple of 16 to reduce memory fragmentation</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.ComputeAlignedSize(System.Int32)">
            <summary>Round a size to a multiple of 16</summary>
            <param name="size">Minimum size required</param>
            <returns>Size rounded up to a multiple of 16</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceWriter.NextPowerOfTwo(System.Int32)">
            <summary>Round a number to the next power of 2</summary>
            <param name="x">Positive integer that will be rounded up (if not already a power of 2)</param>
            <returns>Smallest power of 2 that is greater then or equal to <paramref name="x"/></returns>
            <remarks>Will return 1 for <paramref name="x"/> = 0 (because 0 is not a power 2 !), and will throws for <paramref name="x"/> &lt; 0</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="x"/> is a negative number</exception>
        </member>
        <member name="P:FoundationDB.Client.Utils.SliceWriter.HasData">
            <summary>Returns true is the buffer contains at least some data</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.TransactionHandle">
            <summary>Wrapper on a FDBTransaction*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbSafeHandle">
            <summary>Base class for all wrappers on FDBxxxx* opaque pointers</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbSafeHandle.Destroy(System.IntPtr)">
            <summary>Call the appropriate fdb_T_destroy(..)</summary>
            <param name="handle">Handle on the FDBFuture</param>
        </member>
        <member name="P:FoundationDB.Client.Native.FdbSafeHandle.Handle">
            <summary>Retourne the value of the FDBFuture handle</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNative.FDB_C_DLL">
            <summary>Name of the C API dll used for P/Invoking</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNative.FdbCLib">
            <summary>Handle on the native FDB C API library</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNative.LibraryLoadError">
            <summary>Exception that was thrown when we last tried to load the native FDB C library (or null if nothing wrong happened)</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.ToNativeString(System.String,System.Boolean)">
            <summary>Converts a string into an ANSI byte array</summary>
            <param name="value">String to convert (or null)</param>
            <param name="nullTerminated">If true, adds a terminating \0 at the end (C-style strings)</param>
            <param name="length">Receives the size of the string including the optional NUL terminator (or 0 if <paramref name="value"/> is null)</param>
            <returns>Byte array with the ANSI-encoded string with an optional NUL terminator, or null if <paramref name="value"/> was null</returns>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.GetError(FoundationDB.Client.FdbError)">
            <summary>fdb_get_error</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.SelectApiVersionImpl(System.Int32,System.Int32)">
            <summary>fdb_select_api_impl</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.SelectApiVersion(System.Int32)">
            <summary>fdb_select_api_impl</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.GetMaxApiVersion">
            <summary>fdb_get_max_api_version</summary>
        </member>
        <member name="P:FoundationDB.Client.Native.FdbNative.IsLoaded">
            <summary>Returns true if the C API dll has been loaded properly</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbNative.Stubs">
            <summary>Contain all the stubs to the methods exposed by the C API library</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.ClusterHandle">
            <summary>Wrapper on a FDBCluster*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.DatabaseHandle">
            <summary>Wrapper on a FDBDatabase*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FutureHandle">
            <summary>Wrapper on a FDBFuture*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.UnmanagedLibrary">
            <summary>Native Library Loader</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.LoadLibrary(System.String)">
            <summary>Load a native library into the current process</summary>
            <param name="path">Path to the native dll.</param>
            <remarks>Throws exceptions on failure. Most common failure would be file-not-found, or that the file is not a  loadable image.</remarks>
            <exception cref="T:System.IO.FileNotFoundException">if fileName can't be found</exception>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.#ctor(FoundationDB.Client.Native.UnmanagedLibrary.SafeLibraryHandle,System.String)">
            <summary>Constructor to load a dll and be responible for freeing it.</summary>
            <param name="handle">Handle to the loaded library</param>
            <param name="path">Full path of library to load</param>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.GetUnmanagedFunction``1(System.String)">
            <summary>
            Dynamically lookup a function in the dll via kernel32!GetProcAddress.
            </summary>
            <param name="functionName">raw name of the function in the export table.</param>
            <returns>null if function is not found. Else a delegate to the unmanaged function.
            </returns>
            <remarks>GetProcAddress results are valid as long as the dll is not yet unloaded. This
            is very very dangerous to use since you need to ensure that the dll is not unloaded
            until after you're done with any objects implemented by the dll. For example, if you
            get a delegate that then gets an IUnknown implemented by this dll,
            you can not dispose this library until that IUnknown is collected. Else, you may free
            the library and then the CLR may call release on that IUnknown and it will crash.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.Dispose">
            <summary>Call FreeLibrary on the unmanaged dll. All function pointers handed out from this class become invalid after this.</summary>
            <remarks>This is very dangerous because it suddenly invalidate everything retrieved from this dll. This includes any functions handed out via GetProcAddress, and potentially any objects returned from those functions (which may have an implemention in the dll)./// </remarks>
        </member>
        <member name="P:FoundationDB.Client.Native.UnmanagedLibrary.Path">
            <summary>Path of the native library, as passed to LoadLibrary</summary>
        </member>
        <member name="P:FoundationDB.Client.Native.UnmanagedLibrary.Handle">
            <summary>Unmanaged resource. CLR will ensure SafeHandles get freed, without requiring a finalizer on this class.</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.FdbConverters">
            <summary>Helper class to convert object from one type to another</summary>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.#cctor">
            <summary>Static ctor that initialize the default converters</summary>
        </member>
        <member name="F:FoundationDB.Client.Converters.FdbConverters.Converters">
            <summary>Map of all known converters from T to R</summary>
            <remarks>No locking required, because all changes will replace this instance with a new Dictionary</remarks>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.RegisterDefaultConverters">
            <summary>Register all the default converters</summary>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.FailCannotConvert(System.Type,System.Type)">
            <summary>Helper method to throw an exception when we don't know how to convert from <paramref name="source"/> to <paramref name="destination"/></summary>
            <param name="source"></param>
            <param name="destination"></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.CreateCaster(System.Type)">
            <summary>Create a new delegate that cast a boxed valued of type T (object) into a T</summary>
            <returns>Delegate that is of type Func&lt;object, <param name="type"/>&gt;</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Create``2(System.Func{``0,``1})">
            <summary>Helper method that wraps a lambda function into a converter</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Lambda that converts a value of type <typeparamref name="T"/> into a value of type <typeparamref name="R"/></param>
            <returns>Converters that wraps the lambda</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.RegisterUnsafe``2(System.Func{``0,``1})">
            <summary>Add a new known converter (without locking)</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Lambda that converts a value of type <typeparamref name="T"/> into a value of type <typeparamref name="R"/></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Register``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1})">
            <summary>Registers a new converter</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Lambda that converts a value of type <typeparamref name="T"/> into a value of type <typeparamref name="R"/></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.GetConverter``2">
            <summary>Returns a converter that converts <typeparamref name="T"/>s into <typeparamref name="R"/>s</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <returns>Valid convertir for this types, or an exception if there are no known convertions</returns>
            <exception cref="T:System.InvalidOperationException">No valid converter for these types was found</exception>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Convert``2(``0)">
            <summary>Convert a value of type <typeparamref name="T"/> into type <typeparamref name="R"/></summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="value">Value to convert</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Unbox``1(System.Object)">
            <summary>Cast a boxed value (known to be of type <typeparamref name="T"/>) into an unboxed value</summary>
            <typeparam name="T">Runtime type of the value</typeparam>
            <param name="value">Value that is known to be of type <typeparamref name="T"/>, but is boxed into an object</param>
            <returns>Original value casted into its runtime type</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertBoxed``1(System.Object)">
            <summary>Convert a boxed value into type <typeparamref name="R"/></summary>
            <typeparam name="R">Destination type</typeparam>
            <param name="value">Boxed value</param>
            <returns>Converted value, or an exception if there are no known convertions. The value null is converted into default(<typeparamref name="R"/>) by convention</returns>
            <exception cref="T:System.InvalidOperationException">No valid converter for these types was found</exception>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertAll``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Converts all the elements of a sequence</summary>
            <returns>New sequence with all the converted elements</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertAll``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1},System.Collections.Generic.List{``0})">
            <summary>Converts all the elements of a list</summary>
            <returns>New list with all the converted elements</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertAll``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1},``0[])">
            <summary>Converts all the elements of an array</summary>
            <returns>New array with all the converted elements</returns>
        </member>
        <member name="T:FoundationDB.Client.Converters.FdbConverters.Identity`1">
            <summary>Simple converter where the source and destination types are the same</summary>
            <typeparam name="T">Source and Destination type</typeparam>
        </member>
        <member name="T:FoundationDB.Client.Converters.IFdbConverter`2">
            <summary>Class that can convert values of type <typeparamref name="TSource"/> into values of type <typeparamref name="TDestination"/></summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
        </member>
        <member name="T:FoundationDB.Client.Converters.IFdbConverter">
            <summary>Base class of all value converters</summary>
        </member>
        <member name="M:FoundationDB.Client.Converters.IFdbConverter`2.Convert(`0)">
            <summary>Converts a <paramref name="TSource"/> into a <paramref name="TDestination"/></summary>
            <param name="value">Value to convert</param>
            <returns>Converted value</returns>
        </member>
        <member name="T:FoundationDB.Client.Converters.FdbConverters.Anonymous`2">
            <summary>Simple converter that wraps a lambda function</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleFormatter`1">
            <summary>Helper class to get or create tuple formatters</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.Create(System.Func{`0,FoundationDB.Layers.Tuples.IFdbTuple},System.Func{FoundationDB.Layers.Tuples.IFdbTuple,`0})">
            <summary>Create a custom formatter using the provided lambda functions for convert to and from a tuple</summary>
            <param name="from">Lambda that is called to convert a value into a tuple. It SHOULD NOT return null.</param>
            <param name="to">Lambda that is called to convert a tuple back into a value. It CAN return null.</param>
            <returns>Custom formatter</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.CreateAppender(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a formatter that just add or remove a prefix to values</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.CreateDefaultFormatter">
            <summary>Creates and instance of a tuple formatter that is best suited for this type</summary>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.Default">
            <summary>Return the default tuple formatter for this type</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleTypes">
            <summary>
            Constants for the various tuple value types
            </summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Nil">
            <summary>Null/Empty/Void</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Bytes">
            <summary>ASCII String</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Utf8">
            <summary>UTF-8 String</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Guid">
            <summary>128 bits GUID [CUSTOM EXTENSION]</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.IntBase">
            <summary>Base value for integer types (20 +/- n)</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuplePackers">
            <summary>Helper methods used during serialization of values to the tuple binary format</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.GetSerializer``1(System.Boolean)">
            <summary>Returns a lambda that will be abl to serialize values of type <typeparamref name="T"/></summary>
            <typeparam name="T">Type of values to serialize</typeparam>
            <returns>Reusable action that knows how to serialize values of type <typeparamref name="T"/> into binary buffers, or an exception if the type is not supported</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeObjectTo(FoundationDB.Client.Utils.SliceWriter@,System.Object)">
            <summary>Serialize an untyped object, by checking its type at runtime</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Untyped value whose type will be inspected at runtime</param>
            <remarks>May throw at runtime if the type is not supported</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,FoundationDB.Client.Slice)">
            <summary>Writes a slice as a byte[] array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Byte[])">
            <summary>Writes a byte[] array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.ArraySegment{System.Byte})">
            <summary>Writes an array segment as a byte[] array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Char)">
            <summary>Writes a char as Unicode string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Boolean)">
            <summary>Writes a boolean as an integer</summary>
            <remarks>Uses 0 for false, and -1 for true</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Nullable{System.Boolean})">
            <summary>Writes a boolean as an integer or null</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.SByte)">
            <summary>Writes a signed byte as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Byte)">
            <summary>Writes an unsigned byte as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Int16)">
            <summary>Writes a signed word as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.UInt16)">
            <summary>Writes an unsigned word as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Int32)">
            <summary>Writes a signed int as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.UInt32)">
            <summary>Writes an unsigned int as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Int64)">
            <summary>Writes a signed long as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.UInt64)">
            <summary>Writes an unsigned long as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.String)">
            <summary>Writes a string as an Unicode string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.DateTime)">
            <summary>Writes a DateTime converted to a number of ticks encoded as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.TimeSpan)">
            <summary>Writes a TimeSpan converted to a number of ticks encoded as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,System.Guid)">
            <summary>Writes a Guid as a 128-bit UUID</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,FoundationDB.Client.Uuid)">
            <summary>Writes a Uuid as a 128-bit UUID</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeBoxed(FoundationDB.Client.Slice)">
            <summary>Deserialize a packed element into an object by choosing the most appropriate type at runtime</summary>
            <param name="slice">Slice that contains a single packed element</param>
            <returns>Decoded element, in the type that is the best fit.</returns>
            <remarks>You should avoid working with untyped values as much as possible! Blindly casting the returned object may be problematic because this method may need to return very large intergers as Int64 or even UInt64.</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeFormattable``1(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into a type that implements ITupleFormattable</summary>
            <typeparam name="T">Type of a class that must implement ITupleFormattable and have a default constructor</typeparam>
            <param name="slice">Slice that contains a single packed element</param>
            <returns>Decoded value of type <typeparamref name="T"/></returns>
            <remarks>The type must have a default parameter-less constructor in order to be created.</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeFormattable``1(FoundationDB.Client.Slice,System.Func{``0})">
            <summary>Deserialize a slice into a type that implements ITupleFormattable, using a custom factory method</summary>
            <typeparam name="T">Type of a class that must implement ITupleFormattable</typeparam>
            <param name="slice">Slice that contains a single packed element</param>
            <param name="factory">Lambda that will be called to construct a new instance of values of type <typeparamref name="T"/></param>
            <returns>Decoded value of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeInt32(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an Int32</summary>
            <param name="slice">Slice that contains a single packed element</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeInt64(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an Int64</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeUInt32(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an UInt32</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeUInt64(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an UInt64</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeString(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into a Unicode string</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeGuid(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into Guid</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.Unpack(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from a buffer</summary>
            <param name="buffer">Slice that contains the packed representation of a tuple with zero or more elements</param>
            <returns>Decoded tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.UnpackSingle(FoundationDB.Client.Slice)">
            <summary>Ensure that a slice is a packed tuple that contains a single and valid element</summary>
            <param name="buffer">Slice that should contain the packed representation of a singleton tuple</param>
            <returns>Decoded slice of the single element in the singleton tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.UnpackLast(FoundationDB.Client.Slice)">
            <summary>Only returns the last item of a packed tuple</summary>
            <param name="buffer">Slice that contains the packed representation of a tuple with one or more elements</param>
            <returns>Raw slice corresponding to the last element of the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.ParseNext(FoundationDB.Client.SliceReader@)">
            <summary>Decode the next token from a packed tuple</summary>
            <param name="reader">Parser from wich to read the next token</param>
            <returns>Token decoded, or Slice.Nil if there was no more data in the buffer</returns>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbSlicedTuple">
            <summary>Lazily-evaluated tuple that was unpacked from a key</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbSlicedTuple.m_slices">
            <summary>Buffer containing the original slices. Note: can be bigger than the size of the tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbSlicedTuple.m_offset">
            <summary>Start offset of the first slice of this tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbSlicedTuple.m_count">
            <summary>Number of slices in this tuple.</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`1">
            <summary>Tuple that holds only one item</summary>
            <typeparam name="T1">Type of the item</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`1.Item1">
            <summary>First and only item in the tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`2">
            <summary>Tuple that holds a pair of items</summary>
            <typeparam name="T1">Type of the first item</typeparam>
            <typeparam name="T2">Type of the second item</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`2.Item1">
            <summary>First element of the pair</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`2.Item2">
            <summary>Seconde element of the pair</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`3">
            <summary>Tuple that can hold three items</summary>
            <typeparam name="T1">Type of the first item</typeparam>
            <typeparam name="T2">Type of the second item</typeparam>
            <typeparam name="T3">Type of the third item</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`3.Item1">
            <summary>First element of the triplet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`3.Item2">
            <summary>Second element of the triplet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`3.Item3">
            <summary>Third and last elemnt of the triplet</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbMemoizedTuple">
            <summary>Represents an immutable tuple where the packed bytes are cached</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbMemoizedTuple.Items">
            <summary>Items of the tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbMemoizedTuple.Packed">
            <summary>Packed version of the tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbListTuple">
            <summary>Tuple that can hold any number of untyped items</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbListTuple.m_items">
            <summary>List of the items in the tuple.</summary>
            <remarks>It is supposed to be immutable!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbListTuple.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Create a new tuple from a sequence of items (copied)</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbListTuple.#ctor(System.Object[],System.Int32,System.Int32)">
            <summary>Wrap a List of items</summary>
            <remarks>The list should not mutate and should not be exposed to anyone else!</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleExtensions">
            <summary>Add extensions methods that deal with tuples on various types</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.IsNullOrEmpty(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns true if the tuple is either null or empty</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.IsSingleton(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns true if the tuple is not null, and contains only one item</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToArray(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns an array containing all the objects of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.GetBytes(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns a byte array containing the packed version of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Concat(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Concatenates two tuples together</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToRange(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Creates a key range containing all children of this tuple, from tuple.pack()+'\0' to tuple.pack()+'\xFF'</summary>
            <param name="tuple">Tuple that is the suffix of all keys</param>
            <returns>Range of all keys suffixed by the tuple. The tuple itself will not be included</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToRange(FoundationDB.Layers.Tuples.IFdbTuple,System.Boolean)">
            <summary>Creates a key range containing all children of tuple, optionally including the tuple itself.</summary>
            <param name="tuple">Tuple that is the prefix of all keys</param>
            <param name="includePrefix">If true, the tuple key itself is included, if false only the children keys are included</param>
            <returns>Range of all keys suffixed by the tuple. The tuple itself will be included if <paramref name="includePrefix"/> is true</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Memoize(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Creates pre-packed and isolated copy of this tuple</summary>
            <param name="tuple"></param>
            <returns>Create a copy of the tuple that can be reused frequently to pack values</returns>
            <remarks>If the tuple is already memoized, the current instance will be returned</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToTuple(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from this slice</summary>
            <param name="slice"></param>
            <returns>Unpacked tuple if the slice contains data, FdbTuple.Empty if the slice is empty, or null if the slice is Slice.Nil</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Substring(FoundationDB.Layers.Tuples.IFdbTuple,System.Int32)">
            <summary>Returns a substring of the current tuple</summary>
            <param name="tuple">Current tuple</param>
            <param name="offset">Offset from the start of the current tuple (negative value means from the end)</param>
            <returns>Tuple that contains only the items past the first <param name="offset"/> items of the current tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Substring(FoundationDB.Layers.Tuples.IFdbTuple,System.Int32,System.Int32)">
            <summary>Returns a substring of the current tuple</summary>
            <param name="tuple">Current tuple</param>
            <param name="offset">Offset from the start of the current tuple (negative value means from the end)</param>
            <param name="count">Number of items to keep</param>
            <returns>Tuple that contains only the selected items from the current tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.StartsWith(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Test if the start of current tuple is equal to another tuple</summary>
            <param name="left">Larger tuple</param>
            <param name="right">Smaller tuple</param>
            <returns>True if the beginning of <paramref name="left"/> is equal to <paramref name="right"/> or if both tuples are identical</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Increment(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns a key that is immediately after the packed representation of this tuple</summary>
            <remarks>This is the equivalent of manually packing the tuple and incrementing the resulting slice</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuplePacker`1">
            <summary>Helper class that can serialize values of type <typeparamref name="T"/> to the tuple binary format</summary>
            <typeparam name="T">Type of values to be serialized</typeparam>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePacker`1.SerializeTo(FoundationDB.Client.Utils.SliceWriter@,`0)">
            <summary>Serialize a <typeparamref name="T"/> into a binary buffer</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Value that will be serialized</param>
            <remarks>The buffer does not need to be preallocated.</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePacker`1.Serialize(`0)">
            <summary>Serialize a <typeparamref name="T"/> into a slices</summary>
            <param name="value">Value that will be serialized</param>
            <returns>Slice that contains the binary representation of <paramref name="value"/></returns>
        </member>
        <member name="T:FoundationDB.Async.TaskHelpers">
            <summary>Helper methods to work on tasks</summary>
        </member>
        <member name="F:FoundationDB.Async.TaskHelpers.CompletedTask">
            <summary>Return a task that is already completed</summary>
        </member>
        <member name="F:FoundationDB.Async.TaskHelpers.FalseTask">
            <summary>Already completed task that returns false</summary>
        </member>
        <member name="F:FoundationDB.Async.TaskHelpers.TrueTask">
            <summary>Already completed task that returns true</summary>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.FromResult(System.Boolean)">
            <summary>Returns an already completed boolean task that is either true of false</summary>
            <param name="value">Value of the task</param>
            <returns>Already completed task the returns <paramref name="value"/></returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Default``1">
            <summary>Returns a cached completed task that returns the default value of type <typeparamref name="T"/></summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <returns>Task that is already completed, and returns default(<typeparamref name="T"/>)</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Then``1(System.Threading.Tasks.Task{``0},System.Action{``0})">
            <summary>Continue processing a task, if it succeeded</summary>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>Continue processing a task, if it succeeded</summary>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>Runs a synchronous lambda inline, exposing it as if it was task</summary>
            <typeparam name="R">Type of the result of the lambda</typeparam>
            <param name="lambda">Synchronous lambda function that returns a value, or throws exceptions</param>
            <param name="ct">Cancellation token</param>
            <returns>Task that either contains the result of the lambda, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="lambda"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``1(System.Action{``0},``0,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">Argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``2(System.Action{``0,``1},``0,``1,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``3(System.Action{``0,``1,``2},``0,``1,``2,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <typeparam name="T3">Type of the third parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="arg3">Third argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <typeparam name="T3">Type of the third parameter of the lambda</typeparam>
            <typeparam name="T4">Type of the fourth parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="arg3">Third argument that will be passed to <paramref name="action"/></param>
            <param name="arg4">Fourth argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``5(System.Action{``0,``1,``2,``3,``4},``0,``1,``2,``3,``4,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <typeparam name="T3">Type of the third parameter of the lambda</typeparam>
            <typeparam name="T4">Type of the fourth parameter of the lambda</typeparam>
            <typeparam name="T5">Type of the fifth parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="arg3">Third argument that will be passed to <paramref name="action"/></param>
            <param name="arg4">Fourth argument that will be passed to <paramref name="action"/></param>
            <param name="arg5">Fifth argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.WithCancellation``2(System.Func{``0,``1})">
            <summary>Wraps a classic lambda into one that supports cancellation</summary>
            <param name="lambda">Lambda that does not support cancellation</param>
            <returns>New lambda that will check if the token is cancelled before calling <paramref name="lambda"/></returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.WithCancellation``2(System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Wraps a classic lambda into one that supports cancellation</summary>
            <param name="lambda">Lambda that does not support cancellation</param>
            <returns>New lambda that will check if the token is cancelled before calling <paramref name="lambda"/></returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.FromCancellation``1(System.Threading.CancellationToken)">
            <summary>Returns a cancelled Task that is linked with a specific token</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="cancellationToken">Cancellation token that should already be cancelled</param>
            <returns>Task in the cancelled state that is linked with this cancellation token</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Canceled``1">
            <summary>Returns a cancelled Task that is not linked to any particular token</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <returns>Task in the cancelled state</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.FromException``1(System.Exception)">
            <summary>Returns a failed Task that wraps an exception</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="e">Exception that will be wrapped in the task</param>
            <returns>Task that is already completed, and that will rethrow the exception once observed</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancel(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel a CancellationTokenSource</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled</param>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancelAndDispose(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel and dispose a CancellationTokenSource</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled and disposed</param>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancelDefered(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel a CancellationTokenSource, executing the registered callbacks on the thread pool</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled</param>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancelAndDisposeDefered(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel and dispose a CancellationTokenSource, executing the registered callbacks on the thread pool</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled and disposed</param>
        </member>
        <member name="T:FoundationDB.Async.TaskHelpers.Cache`1">
            <summary>Helper type cache class</summary>
        </member>
        <member name="P:FoundationDB.Async.TaskHelpers.Cache`1.Nop">
            <summary>Returns a lambda function that returns the default value of <typeparamref name="T"/></summary>
        </member>
        <member name="P:FoundationDB.Async.TaskHelpers.Cache`1.Identity">
            <summary>Returns the identity function for <typeparamref name="T"/></summary>
        </member>
    </members>
</doc>
